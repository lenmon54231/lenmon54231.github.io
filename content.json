{"meta":{"title":"Blog|lenMon's","subtitle":"记录博客","description":"HTML，CSS,JAVASCRIPT,前端，Vue","author":"lenMon","url":"http://lenmon54231.github.io.git","root":"/"},"pages":[],"posts":[{"title":"cancletoken的使用（取消上一次的请求）","slug":"cancletoken的使用（取消上一次的请求）","date":"2020-07-01T09:16:26.000Z","updated":"2020-07-01T08:37:07.062Z","comments":true,"path":"2020/07/01/cancletoken的使用（取消上一次的请求）/","link":"","permalink":"http://lenmon54231.github.io.git/2020/07/01/cancletoken%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E5%8F%96%E6%B6%88%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E8%AF%B7%E6%B1%82%EF%BC%89/","excerpt":"cancletoken的使用（取消上一次的请求）当上一次请求没有完成时，再次发起请求，需要首先结束上一次请求。然后再发起新的请求 axios有提供cancletoken的方案，记录如下","text":"cancletoken的使用（取消上一次的请求）当上一次请求没有完成时，再次发起请求，需要首先结束上一次请求。然后再发起新的请求 axios有提供cancletoken的方案，记录如下 需求描述现在又个tabs切换，第一个tab请求数据较大，需要10秒获取数据，第二个tab需求请求5秒，第三个需要请求1秒。 当点击第一个时，等待1秒后，再切换第二个tab，再等待1秒，切换第三个tab。 数据的显示会首先显示第三次请求的数据，然后显示第二次请求的数据，最后显示到页面上渲染出来的时第一次请求到的数据。这个是不正确的，需要显示第三次请求的数据。 解决代码1const service = axios.create(&#123;2 // process.env.NODE_ENV === 'development' 来判断是否开发环境3 baseURL: process.env.NODE_ENV === 'development' ? '/' : host.host,4 timeout: 600000005&#125;);6let cancel = null;7let url = null;8service.interceptors.request.use(config =&gt; &#123;9 // 在 cardCertificateReceive 页面中，存在tab切换发起多次请求需求，需要在本次请求时取消上次请求，故添加取消请求拦截10 if (typeof (cancel) == 'function') &#123;11 if (url == config.url)12 cancel('强制取消了请求')13 &#125;14 url = config.url;15 // 将cancel变成function16 config['cancelToken'] = new axios.CancelToken(function (c) &#123;17 console.log(c, 'c')18 cancel = c19 &#125;)20 return config;21&#125;, error =&gt; &#123;22 return Promise.reject();23&#125;);24service.interceptors.response.use(response =&gt; &#123;25 if (response.status === 200) &#123;26 if (response.data.code === 200) &#123;27 //请求成功后，将cancel置为null。以通过下次请求。28 cancel = null;29 url = null;30 return response.data;31 &#125; 32&#125;, error =&gt; &#123;33&#125;); 核心1config['cancelToken'] = new axios.CancelToken(function (c) &#123;2 console.log(c, 'c')3 cancel = c4 &#125;) new axios.CancelToken，函数内带了一个c这个参数。这个c打印出来是一个function，如下： 1cancel(message) &#123;2 if (token.reason) &#123;3 // Cancellation has already been requested4 return;5 &#125;67 token.reason = new Cancel(message);8 resolvePromise(token.reason);9 &#125; 如若直接使用cancletoken还会导致一个结果，就是当页面初始化，需要同时发起多个请求时，会导致有些请求被‘误判’，从而被终止掉，所以又加个一个url，只判断相同的请求的情况下，才执行终止。","categories":[],"tags":[{"name":"cancletoken","slug":"cancletoken","permalink":"http://lenmon54231.github.io.git/tags/cancletoken/"},{"name":"vue","slug":"vue","permalink":"http://lenmon54231.github.io.git/tags/vue/"}]},{"title":"路由守卫使用-判断登录状态","slug":"路由守卫使用-判断登录状态","date":"2020-03-24T10:16:26.000Z","updated":"2020-07-03T08:03:20.198Z","comments":true,"path":"2020/03/24/路由守卫使用-判断登录状态/","link":"","permalink":"http://lenmon54231.github.io.git/2020/03/24/%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E4%BD%BF%E7%94%A8-%E5%88%A4%E6%96%AD%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81/","excerpt":"路由守卫使用-判断登录状态之前已经通过local storage模拟了注册登录机制，从而控制了页面根据不同的登录状态显示内容的不同。 当用户已经登录的情况下： 首页右上角会显示center和register，而不是login和register 可以直接通过movielist界面看到购物车内容，并且进入pay界面 当没有登录的情况下，不能显示center和购物车内容。 这其中还有一个问题，登录状态模拟的是10分钟有效期。当有效期结束，但是页面还停留在center页面时，再次刷新页面，依旧会停留再center页面，这个不符合逻辑。 应当再次刷新后，直接跳转到login界面。 这个可以通过vue-router的路由守卫去实现，如下；","text":"路由守卫使用-判断登录状态之前已经通过local storage模拟了注册登录机制，从而控制了页面根据不同的登录状态显示内容的不同。 当用户已经登录的情况下： 首页右上角会显示center和register，而不是login和register 可以直接通过movielist界面看到购物车内容，并且进入pay界面 当没有登录的情况下，不能显示center和购物车内容。 这其中还有一个问题，登录状态模拟的是10分钟有效期。当有效期结束，但是页面还停留在center页面时，再次刷新页面，依旧会停留再center页面，这个不符合逻辑。 应当再次刷新后，直接跳转到login界面。 这个可以通过vue-router的路由守卫去实现，如下； vue-router路由守卫配置一开始犯了一个错误，将router.beforeEach（）放到了router中的index.js中了，这个明显不对。、 应当将其配置到main.js中。 并且需要注意的是，router.beforeEach（）需要放置到new vue之前 main.js配置如下： 1import Vue from 'vue'2import App from './App.vue'3import router from './router' //引入router4import store from './store'56Vue.config.productionTip = false78import common from '@/comF/common.js'9Vue.prototype.common = common1011import axios from 'axios'12Vue.prototype.axios = axios1314// 路由变化跳转页面回到顶部15router.afterEach((to,from,next) =&gt; &#123;16 window.scrollTo(0,0);17&#125;)1819Vue.filter(\"price\",function(value) &#123;20 var num2 = Number(value).toFixed(2);21 var num = num2.toString().replace(/(\\d)(?=(\\d&#123;3&#125;)+(?!\\d))/g, \"$1,\");22 return num;23&#125;)2425// 全局路由守卫26router.beforeEach((to, from, next) =&gt; &#123;27 let nameLists = [\"/center\", \"/mall/pay\"]28 let isLogin = JSON.parse(window.localStorage.getItem(\"passUsrInfo\")) ? JSON.parse(window.localStorage.getItem(\"passUsrInfo\")).token : \"\";29 let index = nameLists.findIndex(v =&gt; v == to.path)30 if (index &gt; -1) &#123; // 判断该路由是否需要登录权限31 console.log(\"1\")32 if (isLogin) &#123; // 判断是否已经登录33 console.log(\"11\")34 next()35 &#125;36 else &#123;37 console.log(\"12\")38 next(&#123;39 path: '/loading',40 query: &#123; redirect: to.fullPath &#125; // 将跳转的路由path作为参数，登录成功后跳转到该路由41 &#125;)42 &#125;43 &#125;44 else &#123;45 next()46 &#125;47&#125;)4849new Vue(&#123;50 router,51 store,52 render: h =&gt; h(App)53&#125;).$mount('#app') 说明： import router from ‘./router’ //引入router router.beforeEach((to, from, next) //设置路由守卫 new Vue（）//new 一个vue router的配置就按照正常的配置进行。 实现效果如下图： 登录至个人中心后，删除local storage的token，然后刷新页面，会自动跳转至loading，两秒钟后再跳转至login页面。","categories":[],"tags":[{"name":"路由守卫","slug":"路由守卫","permalink":"http://lenmon54231.github.io.git/tags/%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/"},{"name":"vue-router","slug":"vue-router","permalink":"http://lenmon54231.github.io.git/tags/vue-router/"}]},{"title":"原生JS方法记录","slug":"原生JS方法记录","date":"2020-03-18T09:16:26.000Z","updated":"2020-07-03T08:01:20.797Z","comments":true,"path":"2020/03/18/原生JS方法记录/","link":"","permalink":"http://lenmon54231.github.io.git/2020/03/18/%E5%8E%9F%E7%94%9FJS%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/","excerpt":"原生JS方法记录记录原生JS实现的功能通过框架实现的功能，如何通过原生JS实现，记录遇到的实现代码","text":"原生JS方法记录记录原生JS实现的功能通过框架实现的功能，如何通过原生JS实现，记录遇到的实现代码 js动态添加页面的icon图标1(function() &#123;2 var link = document.createElement('link');3 link.type = 'image/x-icon';4 link.rel = 'shortcut icon';5 link.href = '/images/366/favicon.ico';6 document.getElementsByTagName('head')[0].appendChild(link);7&#125;()); 记录图片懒加载的实现图片懒加载如果是一个图片较多的网站，比如照片类网站，会涉及到打开网站后，一次性向服务器发送大量请求，所以有需求：当用户需要查看更多图片的时候再进行请求。 原理 先将img标签的src链接设为同一张图片（比如空白图片），然后给img标签设置自定义属性（比如 data-src）,然后将真正的图片地址存储在data-src中。 当JS监听到该图片元素进入可视窗口时，将自定义属性中的地址存储到src属性中。达到懒加载的效果。 例子 HTML img图片引入地址为统一的一张图片，真正的地址存储在data-src中 1&lt;div class=\"container\"&gt;2 &lt;img src=\"http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&amp;690\" alt=\"1\" data-src=\"http://img4.imgtn.bdimg.com/it/u=951914923,777131061&amp;fm=26&amp;gp=0.jpg\"&gt;3 &lt;img src=\"http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&amp;690\" alt=\"1\" data-src=\"http://img1.imgtn.bdimg.com/it/u=637435809,3242058940&amp;fm=26&amp;gp=0.jpg\"&gt;4 &lt;img src=\"http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&amp;690\" alt=\"1\" data-src=\"http://img1.imgtn.bdimg.com/it/u=3990342075,2367006974&amp;fm=200&amp;gp=0.jpg\"&gt;5 &lt;img src=\"http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&amp;690\" alt=\"1\" data-src=\"http://img1.imgtn.bdimg.com/it/u=1813891576,1754763093&amp;fm=26&amp;gp=0.jpg\"&gt;6 &lt;img src=\"http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&amp;690\" alt=\"1\" data-src=\"http://img4.imgtn.bdimg.com/it/u=2539922263,2810970709&amp;fm=200&amp;gp=0.jpg\"&gt;7&lt;/div&gt; CSS 1&lt;style&gt;2 .container&#123;3 max-width: 800px;4 margin:0 auto;5 &#125;6 .container:after&#123;7 content:\"\";8 display: block;9 clear:both;10 &#125;11 .container img&#123;12 width:50%;13 height:260px;14 float:left;15 &#125;16&lt;/style&gt; JS 1&lt;script&gt;2 3 // 一开始没有滚动的时候，出现在视窗中的图片也会加载4 start();5 6 // 当页面开始滚动的时候，遍历图片，如果图片出现在视窗中，就加载图片7 var clock; //函数节流8 $(window).on('scroll',function()&#123;9 if(clock)&#123;10 clearTimeout(clock);11 &#125;12 clock = setTimeout(function()&#123;13 start()14 &#125;,200)15 &#125;)16 17 function start()&#123;18 $('.container img').not('[data-isLoading]').each(function () &#123;19 if (isShow($(this))) &#123;20 loadImg($(this));21 &#125;22 &#125;)23 &#125;24 25 26 // 判断图片是否出现在视窗的函数27 function isShow($node)&#123;28 return $node.offset().top &lt;= $(window).height()+$(window).scrollTop();29 &#125;30 31 // 加载图片的函数，就是把自定义属性data-src 存储的真正的图片地址，赋值给src32 function loadImg($img)&#123;33 $img.attr('src', $img.attr('data-src'));34 35 // 已经加载的图片，我给它设置一个属性，值为1，作为标识36 // 弄这个的初衷是因为，每次滚动的时候，所有的图片都会遍历一遍，这样有点浪费，所以做个标识，滚动的时候只遍历哪些还没有加载的图片37 $img.attr('data-isLoading',1);38 &#125;39 40&lt;/script&gt; js实现效果1var clock; //函数节流 2$(window).on('scroll',function()&#123;3 if(clock)&#123;4 clearTimeout(clock);5 &#125;6 clock = setTimeout(function()&#123;7 start()8 &#125;,200)9&#125;) 这里有用到一个节流函数，200ms只执行一次加载图片函数，里面有if的判断条件是延迟函数本身，当settimeout执行时，判断为真，当settimeout不执行，为假。 1function start()&#123;2 $('.container img').not('[data-isLoading]').each(function () &#123;3 if (isShow($(this))) &#123;4 loadImg($(this));5 &#125;6 &#125;)7&#125; .not 函数是jq的用法，是将对象循环，并且将符合条件的对象剔除出数组，这里data-isloading在图片的src改变后，后续有将其赋值为1了。 平滑上移到顶部 公共方法完美平滑实现一个“回到顶部在实际应用中，经常用到滚动到页面顶部或某个位置，一般简单用锚点处理或用js将document.body.scrollTop设置为0，结果是页面一闪而过滚到指定位置，不是特别友好。我们想要的效果是要有点缓冲效果。 现代浏览器陆续意识到了这种需求，scrollIntoView意思是滚动到可视，css中提供了scroll-behavior属性，js有Element.scrollIntoView()方法。 scroll-behavior 纯CSS实现现在css支持了新的功能，scroll-behavior属性可取值auto|smooth|inherit|unset scroll-behavior: smooth;是我们想要的缓冲效果。在PC浏览器中，页面默认滚动是在标签上，移动端大多数在标签上，在我们想要实现平滑“回到顶部”，只需在这两个标签上都加上： 1html, body &#123;2 scroll-behavior: smooth;3&#125; 当然，这个实现方法现在支持度比较不友好 Element.scrollIntoView() 新的方法Element.scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内。 语法 1element.scrollIntoView(); // 等同于element.scrollIntoView(true) 2element.scrollIntoView(alignToTop); // Boolean型参数 3element.scrollIntoView(scrollIntoViewOptions); // Object型参数 参数 alignToTop可选 一个Boolean值： 如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。相应的 scrollIntoViewOptions: {block: &quot;start&quot;, inline: &quot;nearest&quot;}。这是这个参数的默认值。 如果为false，元素的底端将和其所在滚动区的可视区域的底端对齐。相应的scrollIntoViewOptions: {block: &quot;end&quot;, inline: &quot;nearest&quot;}。 scrollIntoViewOptions 可选 一个包含下列属性的对象： behavior 可选 定义动画过渡效果， &quot;auto&quot;或 &quot;smooth&quot; 之一。默认为 &quot;auto&quot;。 block 可选 定义垂直方向的对齐， &quot;start&quot;, &quot;center&quot;, &quot;end&quot;, 或 &quot;nearest&quot;之一。默认为 &quot;start&quot;。 inline 可选 定义水平方向的对齐， &quot;start&quot;, &quot;center&quot;, &quot;end&quot;, 或 &quot;nearest&quot;之一。默认为 &quot;nearest&quot;。 例子 1var element = document.getElementById(\"box\");23element.scrollIntoView();4element.scrollIntoView(false);5element.scrollIntoView(&#123;block: \"end\"&#125;);6element.scrollIntoView(&#123;behavior: \"instant\", block: \"end\", inline: \"nearest\"&#125;); 当然，兼容性也是有问题的。 向下兼容要达到所有浏览器都有相同（类似）效果，那就要把剩余不支持scroll-behavior属性的浏览器揪出来，用js去完成使命了。 注意点 判断是否支持scroll-behavior属性 1if(typeof window.getComputedStyle(document.body).scrollBehavior === 'undefined') &#123;2 // 兼容js代码3&#125; else &#123;4 // 原生滚动api5 // Element.scrollIntoView()6&#125; 缓冲功能的实现 原理： 1var position = position + (destination - position) / n; 贴上代码 1&lt;script type=\"javascript\"&gt;2 var scrollTopSmooth = function (position) &#123;3 // 不存在原生`requestAnimationFrame`，用`setTimeout`模拟替代4 if (!window.requestAnimationFrame) &#123;5 window.requestAnimationFrame = function (cb) &#123;6 return setTimeout(cb, 17);7 &#125;;8 &#125;9 // 当前滚动高度10 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;11 // step12 var step = function () &#123;13 var distance = position - scrollTop;14 scrollTop = scrollTop + distance / 5;15 if (Math.abs(distance) &lt; 1) &#123;16 window.scrollTo(0, position);17 &#125; else &#123;18 window.scrollTo(0, scrollTop);19 requestAnimationFrame(step);20 &#125;21 &#125;;22 step();23&#125;24$backToTop = document.querySelector('.back-to-top')25$backToTop.addEventListener('click', function () &#123;26 scrollTopSmooth(0);27&#125;, false); 28&lt;/script&gt; 简单封装上面缓冲算法和当前滚动业务代码耦合在一起了，下面单独拆解出单独一个函数。 1/**2* 缓冲函数3* @param &#123;Number&#125; position 当前滚动位置4* @param &#123;Number&#125; destination 目标位置5* @param &#123;Number&#125; rate 缓动率6* @param &#123;Function&#125; callback 缓动结束回调函数 两个参数分别是当前位置和是否结束7*/89var easeout = function (position, destination, rate, callback) &#123;10 if (position === destination || typeof destination !== 'number') &#123;11 return false;12 &#125;13 destination = destination || 0;14 rate = rate || 2;15 // 不存在原生`requestAnimationFrame`，用`setTimeout`模拟替代16 if (!window.requestAnimationFrame) &#123;17 window.requestAnimationFrame = function (fn) &#123;18 return setTimeout(fn, 17);19 &#125;20 &#125;21 var step = function () &#123;22 position = position + (destination - position) / rate;23 if (Math.abs(destination - position) &lt; 1) &#123;24 callback(destination, true);25 return;26 &#125;27 callback(position, false);28 requestAnimationFrame(step);29 &#125;;30 step();31&#125; 拆分后，这个小缓冲算法就可以被重复调用啦，而且，适用于滚动到指定位置（不仅仅是到顶部）和缓冲率（控制滚动快慢），当前小demo调用： 1var scrollTopSmooth = function (position) &#123;2 // 当前滚动高度3 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;4 easeout(scrollTop, position, 5, function (val) &#123;5 window.scrollTo(0, val);6 &#125;);7&#125;8$backToTop = document.querySelector('.back-to-top')9$backToTop.addEventListener('click', function () &#123;10 scrollTopSmooth(200);11&#125;, false); 需要放入公共方法中去： 在main.js中，可以将公共方法添加到vue的原型上去，从而在所有的页面都可以实现调用： 1import common from '@/comF/common.js'2Vue.prototype.common = common34import axios from 'axios'5Vue.prototype.axios = axios 函数防抖和节流/闭包函数节流和防抖函数节流：所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数 函数防抖：所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间 防抖例子防抖函数分为非立即执行版和立即执行版。 主要实现方式就是通过执行settimeout这个函数，每次触发延迟对应时间后再执行内部函数 非立即执行防抖函数 1function debounce(func, wait) &#123;2 let timeout;3 return function () &#123;4 let context = this;5 let args = arguments;67 if (timeout) clearTimeout(timeout);8 9 timeout = setTimeout(() =&gt; &#123;10 func.apply(context, args)11 &#125;, wait);12 &#125;13&#125;14content.onmousemove = debounce(count,1000); //调用函数 立即执行防抖函数 1function debounce(func,wait) &#123;2 let timeout;3 return function () &#123;4 let context = this;5 let args = arguments;67 if (timeout) clearTimeout(timeout);89 let callNow = !timeout;10 timeout = setTimeout(() =&gt; &#123;11 timeout = null;12 &#125;, wait)1314 if (callNow) func.apply(context, args)15 &#125;16&#125;17content.onmousemove = debounce(count,1000); //调用函数 双剑合璧版： 1function debounce(func,wait,immediate) &#123;2 let timeout;34 return function () &#123;5 let context = this;6 let args = arguments;78 if (timeout) clearTimeout(timeout);9 if (immediate) &#123;10 var callNow = !timeout;11 timeout = setTimeout(() =&gt; &#123;12 timeout = null;13 &#125;, wait)14 if (callNow) func.apply(context, args)15 &#125;16 else &#123;17 timeout = setTimeout(function()&#123;18 func.apply(context, args)19 &#125;, wait);20 &#125;21 &#125;22&#125; 节流例子对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版 主要实现是通过定位时间差来判断是否执行函数 时间戳 1function throttle(func, wait) &#123;2 let previous = 0;3 return function() &#123;4 let now = Date.now();5 let context = this;6 let args = arguments;7 if (now - previous &gt; wait) &#123;8 func.apply(context, args);9 previous = now;10 &#125;11 &#125;12&#125;13content.onmousemove = throttle(count,1000); 定时器 1function throttle(func, wait) &#123;2 let timeout;3 return function() &#123;4 let context = this;5 let args = arguments;6 if (!timeout) &#123;7 timeout = setTimeout(() =&gt; &#123;8 timeout = null;9 func.apply(context, args)10 &#125;, wait)11 &#125;1213 &#125;14&#125;15content.onmousemove = throttle(count,1000); 合并版本 1function throttle(func, wait ,type) &#123;2 if(type===1)&#123;3 let previous = 0;4 &#125;else if(type===2)&#123;5 let timeout;6 &#125;7 return function() &#123;8 let context = this;9 let args = arguments;10 if(type===1)&#123;11 let now = Date.now();1213 if (now - previous &gt; wait) &#123;14 func.apply(context, args);15 previous = now;16 &#125;17 &#125;else if(type===2)&#123;18 if (!timeout) &#123;19 timeout = setTimeout(() =&gt; &#123;20 timeout = null;21 func.apply(context, args)22 &#125;, wait)23 &#125;24 &#125;25 &#125;26&#125; 区别可以看到 ：非立即执行防抖函数 和 定时器版节流函数 比较相似。 主要区别是其中的判断条件： 节流函数是判断执行settime函数没有执行，则让settime函数执行，达到一定时间内只执行一次的目的。 防抖函数是判断settime函数执行，则让settime函数再执行一次，达到每次触发都延迟 原理防抖是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，都会清除当前的 timer 然后重新设置超时调用，即重新计时。这样一来，只有最后一次操作能被触发。 节流是通过判断是否到达一定时间来触发函数，若没到规定时间则使用计时器延后，而下一次事件则会重新设定计时器。 防抖函数中的闭包复制一份防止丢失 debounce函数debounce函数，俗称防抖函数，专治input、resize、scroll等频繁操作打爆浏览器或其他资源。前端面试几乎必考，当然肯定会做一些变化。 1&lt;script&gt;2 var handler = function () &#123;3 console.log(this, Date.now());4 &#125;5 document.getElementById('input').addEventListener('input', handler);6&lt;/script&gt; 现状用户每次输入操作都会触发handler调用，性能浪费。 目标用户一直输入并不触发handler，直到用户停止输入500ms以上，才触发一次handler。 前提是，不修改原有的业务代码，且尽量通用。 思路setTimeout实现计时高阶函数，即function作为参数并且返回function代码实现过程 第一版1function debounce(fn, delay) &#123;2 return function () &#123;3 setTimeout(function () &#123;4 fn();5 &#125;, delay);6 &#125;7&#125; 给handler包上试试 document.getElementById(‘input’).addEventListener(‘input’, debounce(handler, 500));明显不可以！！这样写只不过将每次触发都延时了500ms，并没有减少触发次数。不过我们至少实现了高阶函数，不会破坏原有的业务代码了。那么接下来就试着减少触发次数。 思路就是每次触发先clearTimeout把之前的计时器清掉，再重新setTimout。那么问题来了，第2次进来时，怎么获取到第1次的计时器，并清除呢？ 第二版1function debounce(fn, delay) &#123;2 var timer;3 return function () &#123; // 闭包4 clearTimeout(timer);5 timer = setTimeout(function () &#123;6 fn();7 &#125;, delay);8 &#125;9&#125; 试来试去，发现把timer放到“外面”最好（为什么不放到更外面？），每次调用进来，大家用的都是一个timer，完美。同时，我们的第一个主角登场了——闭包。 闭包闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。——百度百科 网上可以找个很多关于闭包的概念与解释，估计越看越蒙。认识事物需要一个从具象到抽象的过程，以目前的情况来看，我们只要知道，“定义在一个函数（外函数）内部的函数（内函数），并且内函数访问了外函数的变量，这个内函数就叫做闭包”。 最关键的问题，闭包有什么用？从debounce这个例子，我们可以看到，闭包可以让每次触发的handler共享一个变量，通常用到高阶函数的地方，就会用到闭包。再举几个闭包的应用场景，比如给ajax请求加缓存、加锁，为一系列回调设置初始值，防止污染全局或局部变量等。可能这么说大家还是若有若无的，没关系，实践出真知，现实当中肯定会碰到能够应用闭包的地方的。我们继续debounce。 终于解决了触发频率的问题了。但是！细心的同学肯定发现了。我们handler里的console打印出来的this，是不一样的！！！之前的this是input结点，现在的this是window对象。这绝对是不行的，比如我想要在handler里打印input的value，现在怎么做呢？ 第三版1function debounce(fn, delay) &#123;2 // 13 var timer;4 return function () &#123; // 闭包5 // 26 var ctx = this; // this上下文7 clearTimeout(timer);8 timer = setTimeout(function () &#123;9 // 310 fn.apply(ctx); // this上下文调用11 &#125;, delay);12 &#125;13&#125; 解决思路也简单，就是先把正确的this保存起来，我们在这里把this称为“上下文”，大家可以细细品味一下这个词。然后用apply（或call）重新制定一下fn的上下文即可。 上下文thisjs的this是很善变的，谁调用它，它就指向谁，所以“上下文”这个词还是很贴切的。那么，为什么在2处能够得到正确的this呢？涉及到上下文切换的地方，一共有3处，已在上面代码中标了出来。我总结了一个三步定位this法： 第一步，是否立即执行？如果是，跳过第二步！ 第二步，如果不是立即执行，它一定会被转交给某个对象保管，看它被挂在了哪，或者说转交给了谁！ 第三步，这个执行函数挂在谁身上，谁就是this！ 我们来实践一下。 第1处： 我们需要先简单处理一下，debounce其实是挂在window全局上的，写全应该是window.debounce(handler, 500)。第一步，是立即执行的！跳过第二步！第三步，debounce挂在window上！所以this指向是window。 第2处： 先简单处理下，debounce(handler, 500)的执行结果是返回一个函数，所以下面两段代码基本上可以视为等价的 1document.getElementById('input').addEventListener('input', debounce(handler, 500));23document.getElementById('input').addEventListener('input', function () &#123; // 闭包4 // 25 var ctx = this; // this上下文6 clearTimeout(timer);7 timer = setTimeout(function () &#123;8 // 39 fn.apply(ctx); // this上下文调用10 &#125;, delay);11&#125;); 这么一看，就具体多了。第一步，不是立即执行；第二步，addEventListener是挂在dom上的方法，所以addEventListener只能把回调挂在dom上，可以理解成input.handler = function(){}，等行为被触发时才执行。所以它被转交给了input；第三步，handler挂在input上，所以this指向了input！ 第3处： setTimeout是挂在window上的，所以在执行的时候，实际上是window.setTimeout()。我们用伪代码模拟下setTimeout的实现 1window.setTimeout = function(fn, delay)&#123;2 // 因为不能立即执行，所以要找个地方挂fn，就只能把fn转交给它的主子window3 // 假设window存fn的属性叫setTimeoutHandler，与input.handler类似4 window.setTimeoutHandler = fn;5 // 等待delay毫秒……6 window.setTimeoutHandler(); // 执行7&#125; 仔细理解一下，可以发现这里跟dom的回调非常像。第一步，不是立即执行；第二步，setTimeout是挂在window上的方法，所以只能转交给window的某个方法保管（假设叫setTimeoutHandler，名字不重要）；第三步，setTimeoutHandler挂在window上，所以this指向window。 稳妥起见，我们再加一个例子 1var obj = &#123;2 test: function()&#123;3 console.log(this);4 &#125;5&#125;6obj.test(); // obj7setTimeout(obj.test,1000); // window 第一个很简单，立即执行，不用转交。直接可以定位this指向了obj！ 第二个非立即执行，虽然传进去的是obj.test，实际上需要转交给window.setTimeoutHandler保管，即window.setTimeoutHandler = obj.test。所以this指向的是window！ 总之，碰到非立即执行的函数，需要仔细分析一下。 debounce最终版 1function debounce(fn, delay) &#123;2 var timer;3 return function () &#123; // 闭包4 var ctx = this; // this上下文5 var args = arguments;6 clearTimeout(timer);7 timer = setTimeout(function () &#123;8 fn.apply(ctx, args); // this上下文调用9 &#125;, delay);10 &#125;11&#125; 最后，我们再把传参也解决一下（arguments是默认的存储所有传参的类数组对象，时间关系这里就不展开了），完成。 总结debounce是一个很实用也很经典的功能函数，每一行代码都有丰富的内涵。与其类似的还有throttle，可以查查巩固一下。本文主要是想借debounce这个实用的函数引出js当中的两个比较难理解，的点this和闭包。说实话，这两个点想讲明白很难，更靠谱的办法是用大量的实践来消化。本文算是给各位同学种下一颗种子，以后碰到类似的情况时，能够很快的想起本文的内容，帮助自己更好的理解与感悟。 冒泡，捕获与其阻止js addEventListener事件捕获与冒泡,第三个参数详解,阻止事件传播关键点 element.addEventListener(event, function[, useCapture]) event:事件名称,如click function:指定要事件触发时执行的函数,可以传入事件参数 useCapture:可选。布尔值，指定事件是否在捕获或冒泡阶段执行。 默认false:在冒泡阶段执行指定事件 true:在捕获阶段执行事件 event.stopPropagation():阻止事件传播,用于function(event){}中 捕获与冒泡图示： 冒泡js代码： 1function print(e)&#123;2 console.log(this.id);3 &#125;4 aa.addEventListener('click',print);//第三个参数默认为false5 bb.addEventListener('click',print);6 cc.addEventListener('click',print); 输出结果： 1cc2bb3aa 这个结果明显是从内到外去执行的，是冒泡阶段执行，因为默认的是false。 捕获js代码： 1function print(e)&#123;2 console.log(this.id);3 &#125;4 aa.addEventListener('click',print,true);//第三个参数默认为false5 bb.addEventListener('click',print,true);6 cc.addEventListener('click',print,true); 输出结果： 1aa2bb3cc 当改为true时，则要执行捕获阶段，从外到内去执行。 阻止传播行为当有时候不需要点击激活所有的行为时，可以采用对应的方法阻止 js代码如下： 1function print(e)&#123;2 e.stopPropagation();//执行完此函数后,该事件不再继续传播3 console.log(this.id);4 &#125;5 aa.addEventListener('click',print,true);//第三个参数默认为false6 bb.addEventListener('click',print,true);7 cc.addEventListener('click',print,true); 输出结果： 1aa 再点击cc时,捕获cc,执行cc的click函数, 因为print函数中有e.stopPropagation(),所以执行完该函数后,click事件不再传播. 取消默认事件除了冒泡行为，有的时候还会遇到默认事件 什么元素有默认行为呢？如链接，提交按钮等。 阻止默认事件 1//假定有链接&lt;a href=\"http://caibaojian.com/\" id=\"testA\" &gt;caibaojian.com&lt;/a&gt;2var a = document.getElementById(\"testA\");3a.onclick =function(e)&#123;4if(e.preventDefault)&#123;5e.preventDefault();6&#125;else&#123;7window.event.returnValue == false;8&#125;9&#125; 总结当需要停止冒泡行为时，可以使用： 1function stopBubble(e) &#123; 2//如果提供了事件对象，则这是一个非IE浏览器 3if ( e &amp;&amp; e.stopPropagation ) 4 //因此它支持W3C的stopPropagation()方法 5 e.stopPropagation(); 6else 7 //否则，我们需要使用IE的方式来取消事件冒泡 8 window.event.cancelBubble = true; 9&#125; 当需要阻止默认行为时，可以使用: 1//阻止浏览器的默认行为 2function stopDefault( e ) &#123; 3 //阻止默认浏览器动作(W3C) 4 if ( e &amp;&amp; e.preventDefault ) 5 e.preventDefault(); 6 //IE中阻止函数器默认动作的方式 7 else 8 window.event.returnValue = false; 9 return false; 10&#125; 浮动float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 1img2 &#123;3 float:right;4 &#125; 如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。注释：假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 清除浮动浮动会带来什么影响？浮动主要会影响页面的布局，给元素加上浮动后，元素会脱离文档流，从而导致以下的几个现象： 外层父级元素边框不能撑开; 外层父级元素背景不能显示; margin值不能正确显示; 图片如下:代码如下：HTML 1&lt;div class=\"outer\"&gt;2 &lt;div class=\"div1\"&gt;1&lt;/div&gt;3 &lt;div class=\"div2\"&gt;2&lt;/div&gt;4 &lt;div class=\"div3\"&gt;3&lt;/div&gt;5&lt;/div&gt; CSS 1.outer&#123;border: 1px solid #ccc;background: #fc9;color: #fff; margin: 50px auto;padding: 50px;&#125;2.div1&#123;width: 80px;height: 80px;background: red;float: left;&#125;3.div2&#123;width: 80px;height: 80px;background: blue;float: left;&#125;4.div3&#123;width: 80px;height: 80px;background: sienna;float: left;&#125; 如何清除浮动？ 添加新的元素 、应用 clear：bothHTML 1&lt;div class=\"outer\"&gt;2 &lt;div class=\"div1\"&gt;1&lt;/div&gt;3 &lt;div class=\"div2\"&gt;2&lt;/div&gt;4 &lt;div class=\"div3\"&gt;3&lt;/div&gt;5 &lt;div class=\"clear\"&gt;&lt;/div&gt;6&lt;/div&gt; CSS 1.clear&#123;clear:both; height: 0; line-height: 0; font-size: 0&#125; 父级div定义 overflow: auto（注意：是父级div也就是这里的 div.outer）HTML 1&lt;div class=\"outer over-flow\"&gt; //这里添加了一个class2 &lt;div class=\"div1\"&gt;1&lt;/div&gt;3 &lt;div class=\"div2\"&gt;2&lt;/div&gt;4 &lt;div class=\"div3\"&gt;3&lt;/div&gt;5 &lt;!--&lt;div class=\"clear\"&gt;&lt;/div&gt;--&gt;6&lt;/div&gt; CSS 1.over-flow&#123;2 overflow: auto; zoom: 1; //zoom: 1; 是在处理兼容性问题3&#125; 注意:使用overflow属性来清除浮动有一点需要注意，overflow属性共有三个属性值：hidden,auto,visible。我们可以使用hiddent和auto值来清除浮动，但切记不能使用visible值，如果使用这个值将无法达到清除浮动效果，其他两个值都可以，其区据说在于一个对seo比较友好，另个hidden对seo不是太友好，其他区别我就说不上了，也不浪费时间。 :after 方法：（注意：作用于浮动元素的父亲）HTML 1&lt;div class=\"outer\"&gt; //这里添加了一个class2 &lt;div class=\"div1\"&gt;1&lt;/div&gt;3 &lt;div class=\"div2\"&gt;2&lt;/div&gt;4 &lt;div class=\"div3\"&gt;3&lt;/div&gt;5 &lt;!--&lt;div class=\"clear\"&gt;&lt;/div&gt;--&gt;6&lt;/div&gt; CSS 1.outer &#123;zoom:1;&#125; /*==for IE6/7 Maxthon2==*/2.outer :after &#123;clear:both;content:'.';display:block;width: 0;height: 0;visibility:hidden;&#125; /*==for FF/chrome/opera/IE8==*/3&#125; 1) display:block 使生成的元素以块级元素显示,占满剩余空间; 2) height:0 避免生成内容破坏原有布局的高度。 3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互; 4）通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX”,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙； 5）zoom：1 触发IE hasLayout。 通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。 OVER…… What is this？你可能遇到过这样的 JS 面试题： 1var obj = &#123;2foo: function()&#123;3 console.log(this)4&#125;5&#125;67var bar = obj.foo8obj.foo() // 打印出的 this 是 obj9bar() // 打印出的 this 是 window JS（ES5）里面有三种函数调用形式： 1func(p1, p2) 2obj.child.method(p1, p2)3func.call(context, p1, p2) // 先不讲 apply 从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式： 1func.call(context, p1, p2) 这样，this 就好解释了this，就是上面代码中的 context。就这么简单。 this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。 1var obj = &#123;2 foo: function()&#123;3 console.log(this)4 &#125;5&#125;67var bar = obj.foo8obj.foo() // 转换为 obj.foo.call(obj)，this 就是 obj9bar() 10// 转换为 bar.call()11// 由于没有传 context12// 所以 this 就是 undefined13// 最后浏览器给你一个默认的 this —— window 对象 更多的情况 Event Handler 中的 this“ 1btn.addEventListener('click' ,function handler()&#123;2 console.log(this) // 请问这里的 this 是什么3&#125;) 通常来说this的值是触发事件的元素的引用，这种特性在多个相似的元素使用同一个通用事件监听器时非常让人满意。 当使用 addEventListener() 为一个元素注册事件的时候，句柄里的 this 值是该元素的引用。其与传递给句柄的 event 参数的 currentTarget 属性的值一样。 1&#x2F;&#x2F; 当事件被触发时2handler.call(event.currentTarget, event) 3&#x2F;&#x2F; 那么 this 是什么不言而喻 this指向btn。 jQuery Event Handler 中的 this： 1$ul.on(&amp;#39;click&amp;#39;, &amp;#39;li&amp;#39; , function()&#123;2 console.log(this)3&#125;)we 文档： 当jQuery的调用处理程序时，this关键字指向的是当前正在执行事件的元素。对于直接事件而言，this 代表绑定事件的元素。对于代理事件而言，**this 则代表了与 selector** 相匹配的元素。(注意，如果事件是从后代元素冒泡上来的话，那么 this 就有可能不等于 event.target。)若要使用 jQuery 的相关方法，可以根据当前元素创建一个 jQuery 对象，即使用 $(this)。 强制指定this的指向1function handlerWrapper(event)&#123;2 function handler()&#123;3 console.log(this) // 请问这里的 this 是什么4 &#125;56 handler.call(&#123;name:'饥人谷'&#125;, event)7&#125;8btn.addEventListener('click', handlerWrapper) 内部函数的this指向构造函数版this： 1function Fn()&#123;2 this.user &#x3D; &quot;追梦子&quot;;3&#125;4var a &#x3D; new Fn();5console.log(a.user); &#x2F;&#x2F;追梦子 构造函数生成的this指向实例化的对象。 setTimeOut()或setInterval()中的this： 在setTimeOut()或setInterval()这样的方法中，如果传入的函数包含this, 那么，默认情况下，函数中的this会指向window对象。 改变的三种方式： 将当前对象的this存为一个变量 1function doClick()&#123;2 var that = this;3 setInterval(function() &#123;4 console.log(that.msg);5 &#125;, 1000);6&#125; 利用bind()方法 1function doClick()&#123;2 setInterval(function() &#123;3 console.log(this.msg);4 &#125;.bind(this), 1000); //利用bind()将this绑定到这个函数上5&#125; ES6的箭头函数 1function doClick()&#123;2 setInterval(() =&gt; &#123;3 console.log(this.msg);4 &#125;, 100);5 &#125;, 总结如何准确判断 this 指向的是什么？ 1 . 函数是否在 new 中调用 (new 绑定)，如果是，那么 this 绑定的是新创建的对象。 2 . 函数是否通过 call,apply 调用，或者使用了 bind(即硬绑定)，如果是，那么 this 绑定的就是指定的对象。 3 . 函数是否在某个上下文对象中调用 (隐式绑定)，如果是的话，this 绑定的是那个上下文对象。一般是 obj.foo()。 4 . 如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到 undefined，否则绑定到全局对象。 5 . 如果把 Null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。 6 . 如果是箭头函数，箭头函数的 this 继承的是外层代码块的 this。","categories":[],"tags":[{"name":"原生","slug":"原生","permalink":"http://lenmon54231.github.io.git/tags/%E5%8E%9F%E7%94%9F/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://lenmon54231.github.io.git/tags/JavaScript/"}]},{"title":"vue项目上线优化记录","slug":"vue项目上线优化记录","date":"2020-03-12T09:16:26.000Z","updated":"2020-07-03T08:01:43.426Z","comments":true,"path":"2020/03/12/vue项目上线优化记录/","link":"","permalink":"http://lenmon54231.github.io.git/2020/03/12/vue%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/","excerpt":"vue项目上线优化记录项目上线，没有进行备案，所以需要架设于境外服务器，所有访问速度较慢，现在记录所作优化步骤： 引用线上地址 将静态资源放置于网络存储 精灵图减少请求 服务器开通gzip 路由懒加载","text":"vue项目上线优化记录项目上线，没有进行备案，所以需要架设于境外服务器，所有访问速度较慢，现在记录所作优化步骤： 引用线上地址 将静态资源放置于网络存储 精灵图减少请求 服务器开通gzip 路由懒加载 引用线上地址使用的是bootstrap，之前是通过下载到本地，然后引用，当build的时候，会将其一并打包，所以导致js文件过大，所以直接将引用地址改为网络请求，这样，打包后的文件会减小很多。 将静态资源放置于网络存储网站的大部分图片都不会改动，所以将其上传到oss网络存储然后直接引用网络地址，这里采用的是北京的oss，这样从服务器请求的时候是从北京地区请求的图片，相对速度会快一些。 background-image: url(“https://limengtupian.oss-cn-beijing.aliyuncs.com/%E9%A6%96%E9%A1%B5%E7%B2%BE%E7%81%B5%E5%9B%BE/img.png&quot;); 精灵图减少请求每一张图片都会发起一次请求，所以对于一些常用的小图标，我们一般都会将其做成一张图，然后通过定位的方式，显示出其中的一部分，这样的图片就是精灵图。 服务器开通gzipgzip可以直接再服务端的时候，就对要传输的数据先进行一次压缩，减少传输数据的体积，这个概念跟下载游戏文件的时候一般下载下来的都是压缩包是类似的，然后再客户端的浏览器上，会进行解压处理，这样就大大减少了文件体积，减少的传输速度。 由于是采用的vue-cli 3.0 ，查阅网上资料发现，通过3.0去构建的项目，是默认的开启gzip的，那么只需要再服务器上的配置文件修改。 采用的是nginx，所以找到对应的conf文件(/usr/local/nginx/conf)，修改如下： http { gzip on; gzip_min_length 1k; gzip_buffers 4 16k; #gzip_http_version 1.0; gzip_comp_level 6; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; gzip_vary off; gzip_disable “MSIE [1-6].“; } 再次请求，可以通过谷歌浏览器-F12-network-点击任意文件-header内的request header中，可以看到： Accept-Encoding：gzip 已经是通过了zip压缩的文件了，体积明显缩小 路由懒加载单页面应用是会再首页加载的时候将所有的页面直接加载完成，所以会出现首页加载较长的情况，这样就需要采用懒加载，当页面被点击的时候再加载。那么，配置如下： 在router中配置如下： export default { path: ‘/home’, component: () =&gt; import(‘@/views/Home.vue’) } 将其component修改成了() =&gt; import(‘@/views/Home.vue’)。 但是现在路由懒加载不生效，因为cli 3.0 是直接默认会把所有通过import()按需加载的javascript文件加上 prefetch 。 关闭prefetch: (官网示例) 12// vue.config.js3module.exports = &#123;4 chainWebpack: config =&gt; &#123;5 // 移除 prefetch 插件6 config.plugins.delete('prefetch')7 8 // 或者9 // 修改它的选项：10 config.plugin('prefetch').tap(options =&gt; &#123;11 options[0].fileBlacklist = options[0].fileBlacklist || []12 options[0].fileBlacklist.push(/myasyncRoute(.)+?\\.js$/)13 return options14 &#125;)15 &#125; prefetch链接会消耗宽带，如果是在移动端，而且存在大量的chunk，那么可以关掉 prefetch 链接，手动选择要提前获取的代码区块。 1//手动选定要提前获取的代码2import(webpackPrefetch: true, './someAsyncComponent.vue') vue-cli上线 代理接口报404 修改conf前言： 项目使用vue-cli直接生成项目，然后使用proxyTable接口代理后， 在本地调用后台接口，一切正常，但是后期打包上线时，发现页面接口报404，后找到解决办法为： 找到nginx 的conf文件，打开后，修改里面的配置如下： 1 server &#123;2 listen 80;//监听80端口3 server_name localhost;4 location / &#123;5 root html;6 index index.html index.htm;7 try_files $uri $uri/ /index.html; //vue单页面应用，不能刷新，所有会设置这个，避免4048 &#125;9 location /v2/ &#123;10 proxy_set_header X-Real-IP $remote_addr;11 proxy_pass http://douban.uieee.com;12 &#125;13 error_page 500 502 503 504 /50x.html;14 location = /50x.html &#123;15 root html;16 &#125;17&#125; 里面主要添加的配置为： 1location /v2/ &#123;2 proxy_set_header X-Real-IP $remote_addr;3 proxy_pass http://douban.uieee.com;4&#125; 这个/v2/监听，实际上就是我api调用的名字，这个可以在你的vue.config.js里可以去设置： 1module.exports = &#123;2 //axios域代理，解决axios跨域问题3 devServer: &#123;4 proxy: &#123;5 '/v2': &#123;6 target: 'https://douban.uieee.com',7 changeOrigin: true,8 ws: true,9 &#125;10 &#125;11 &#125;12&#125; 我请求的api格式如下： https://douban.uieee.com/v2/movie/top250?start=0&amp;count=12 提供的api文档里面可以看到，所有的api都带有一个相同的字符/v2/。 所以以这个字符为关键字来修改代理。 初始化设置和环境搭建（neginx,centOS，vue的环境搭建）/GitHub相关安装node.js一般来讲, 可以用以下三种方式安装 Node.js： 通过安装包安装(Windows 和 Mac 用户推荐) 通过源码编译安装(Linux用户推荐) 在 Linux 下可以通过 yum|apt-get 安装 通过安装包安装： 源码编译安装： Linux用户： 1curl -O https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v6.10.3&#x2F;node-v6.10.3.tar.gz2tar -xzvf node-v6.10.3.tar.gz3cd node-v6.10.34.&#x2F;configure5make6make install 安装cnpm镜像（可选择） 淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。 1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 2cnpm install [name] 使用vue-cli 安装 如果用npm下载速度慢，可以使用cnpm. 1npm install -g vue-cli init初始模板 目前可用的模板包括： browserify–全功能的Browserify + vueify，包括热加载，静态检测，单元测试 browserify-simple–一个简易的Browserify + vueify，以便于快速开始。 webpack–全功能的Webpack + vueify，包括热加载，静态检测，单元测试 webpack-simple–一个简易的Webpack + vueify，以便于快速开始。 simple - 单个HTML文件中最简单的Vue设置 1vue init &lt;template-name&gt; &lt;project-name&gt; 运行项目 我们的项目选择webpack,使用以下命令: 1vue init webpack vue-todos 输入下面的命令就可以运行这个项目了: 1cd vue-todos2npm install3npm run dev CentOS7安装Nginx安装所需环境Nginx 是 C语言 开发，建议在 Linux 上运行，当然，也可以安装 Windows 版本，本篇则使用 CentOS 7 作为安装环境。 顺序如下： gcc 安装 1yum install gcc-c++ PCRE pcre-devel 安装 1yum install -y pcre pcre-devel zlib 安装 1yum install -y zlib zlib-devel OpenSSL 安装 1yum install -y openssl openssl-devel 下载.tar.gz安装包 1wget -c https:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.12.0.tar.gz 解压 1tar -zxvf nginx-1.12.0.tar.gz2cd nginx-1.12.0 配置 1.&#x2F;configure 编译安装 1make2make install 启动、停止nginx 1cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;2.&#x2F;nginx 3.&#x2F;nginx -s stop4.&#x2F;nginx -s quit5.&#x2F;nginx -s reload 重启 nginx 1cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;2.&#x2F;nginx -s reload CSS Tools: Reset CSS重置css浏览器自带的css属性，一般需要重置，记录如下： 1/* http://meyerweb.com/eric/tools/css/reset/ 2 v2.0 | 201101263 License: none (public domain)4*/56html, body, div, span, applet, object, iframe,7h1, h2, h3, h4, h5, h6, p, blockquote, pre,8a, abbr, acronym, address, big, cite, code,9del, dfn, em, img, ins, kbd, q, s, samp,10small, strike, strong, sub, sup, tt, var,11b, u, i, center,12dl, dt, dd, ol, ul, li,13fieldset, form, label, legend,14table, caption, tbody, tfoot, thead, tr, th, td,15article, aside, canvas, details, embed, 16figure, figcaption, footer, header, hgroup, 17menu, nav, output, ruby, section, summary,18time, mark, audio, video &#123;19 margin: 0;20 padding: 0;21 border: 0;22 font-size: 100%;23 font: inherit;24 vertical-align: baseline;25&#125;26/* HTML5 display-role reset for older browsers */27article, aside, details, figcaption, figure, 28footer, header, hgroup, menu, nav, section &#123;29 display: block;30&#125;31body &#123;32 line-height: 1;33&#125;34ol, ul &#123;35 list-style: none;36&#125;37blockquote, q &#123;38 quotes: none;39&#125;40blockquote:before, blockquote:after,41q:before, q:after &#123;42 content: '';43 content: none;44&#125;45table &#123;46 border-collapse: collapse;47 border-spacing: 0;48&#125; vs code插件记录(更新中)vscode会使用比较多的插件，记录： Auto Close Tag（补充标签） Auto Rename Tag（修改标签） Chinese (Simplified) Language Pack for VS Code Debugger for Chrome Open in Browser Prettier（格式化） Vetur（智能提示补全代码） vscode-icons（美化icon） Bracket Pair Colorizer（括号颜色，快速识别括号位置） 记录： Vetur 使用scss的时候，会遇到vetur报错的情况： 1&lt;style lang=\"scss\" scoped&gt;2 @keyframes glitch-one &#123;3 @for $i from 20 to 30 &#123;4 #&#123;$i / 2&#125;% &#123;5 left: #&#123;randomNum(200, -100)&#125;px;6 clip-path: inset(#&#123;randomNum(150, 30)&#125;px 0 #&#123;randomNum(150, 30)&#125;px);7 &#125;8 &#125;9 &#125; 比如上面的这种情况，就会有红色波浪线提示，但是在浏览器中是正确的。所以需要配置如下： 文件》首选项》设置 右上角三个选项的第一个（打开设置Json） 在大括号内添加最后四行（跟vetur相关的配置） 1&#123;2 \"workbench.iconTheme\": \"vscode-icons\",3 \"[html]\": &#123;4 \"editor.defaultFormatter\": \"vscode.html-language-features\"5 &#125;,6 \"open-in-browser.default\": \"chrome\",7 \"explorer.confirmDragAndDrop\": false,8 \"window.zoomLevel\": 1,9 \"[javascript]\": &#123;10 \"editor.defaultFormatter\": \"vscode.typescript-language-features\"11 &#125;,12 \"explorer.confirmDelete\": false,13 \"vsicons.dontShowNewVersionMessage\": true,14 \"editor.fontSize\": 20,15 \"[css]\": &#123;16 \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"17 &#125;,18 \"vetur.validation.template\": false,19 \"vetur.experimental.templateInterpolationService\": false,20 \"vetur.validation.style\": false,21 \"vetur.validation.script\": false,22&#125; GitHub相关问题GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。 初始设置github记录开始使用GitHub中三点注意： 注册账号会验证邮箱，而163邮箱不能接受验证邮件 注意：注册需要设置邮箱，需要选用qq邮箱或者gmail邮箱，163邮箱发现不能接收到GitHub的邮件！ 新的库，需要设置sshkeys 检查是否有sshkeys 1~&#x2F;.ssh 创建ssh 首先创建一个SSH，在Git Bash中输入 1$ ssh-keygen -t rsa -C “你的邮箱” 然后他就会显示这两行 1Generating public&#x2F;private rsa key pair.2Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;16627&#x2F;.ssh&#x2F;id_rsa): 这是让你输入一个文件名，用于保存刚才生成的 SSH key 代码。如果你不输入，直接回车，那么就会默认生成id_rsa和id_rsa.pub两个秘钥文件（如下提示）。 1Created directory ‘&#x2F;c&#x2F;Users&#x2F;16627&#x2F;.ssh’. 紧接着又会提示你 1Enter passphrase (empty for no passphrase):2Enter same passphrase again: 接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码），当然你还可以不输入密码，直接按回车。那么fetch和push的时候就不需要输入密码。 已经创建成功 添加ssh到GitHub 按照以下的步骤操作： title随便给他起个名字就好。然后是key，这时候你要打开你刚才在电脑上的SSH key。刚才提示你建立的那段文字有SSH key的地址，按照地址找到你的文件，用记事本打开id_rsa.pub文件，全选其中的内容粘贴到网页的Key中即可。 然后你就会受到建立成功的邮件了。 测试一下ssh key 在git Bash 中输入以下代码： 1ssh -T git@github.com2注意是git@github.com，不是你的邮箱。 然后会提示你： 1The authenticity of host ‘github.com (192.30.255.112)’ can’t be established.2RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.3Are you sure you want to continue connecting (yes&#x2F;no)? 正常提示，你只需要YES就可以。如果你创建 SSH key 的时候设置了密码，接下来就会提示你输入密码，如果你没设置密码会提示你: 1Warning: Permanently added ‘github.com,192.30.255.112’ (RSA) to the list of known hosts.2Hi “用户名”! You’ve successfully authenticated, but GitHub does not provide shell access. 需要设置config.name和config.email 按照以下的步骤操作 1git config --global user.name &quot;yourname&quot; 设置用户名2git config --global user.email myemail@qq.com 设置用户邮箱3git config --list 查看git设置列表信息4git config user.name 查看用户名 git推动GitHub提示faild在添加远程库的时候一直验证不成功，一直提示failed to push some refs to git的问题，经过网上查找终于解决了这个问题。 主要问题指向了README.md文件 git步骤如下11. git add . //添加到暂存区22. git commit -m \"备注内容\" //添加到head33. git push -u origin master //添加到远程仓库 其中第三步出错，提示ailed to push some refs to git 解决出现错误的主要原因是github中的README.md文件不在本地代码目录中， 可以通过如下命令进行代码合并【注：pull=fetch+merge] 1git pull --rebase origin master 执行上面代码后可以看到本地代码库中多了README.md文件 此时再执行语句 git push -u origin master即可完成代码上传到github keep-alive 的使用与周期使用keep-alive的时机在搭建 vue 项目时，有某些组件没必要多次渲染，所以需要将组件在内存中进行‘持久化，此时 keep-alive 便可以派上用场了。keep-alive 可以使被包含的组件状态维持不变，即便是组件切换了，其内的状态依旧维持在内存之中。在下一次显示时，也不会重现渲染。 PS：与相似，只是一个抽象组件，它不会在DOM树中渲染(真实或者虚拟都不会)，也不在父组件链中存在，比如：你永远在 this.$parent 中找不到 keep-alive 。 配合router-view去使用有些时候可能需要将整个路由页面一切缓存下来，也就是将 `` 进行缓存。这种使用场景还是蛮多的 1&lt;keep-alive&gt;2 &lt;router-view v-if=\"$router.meta.keepAlive\"&gt;&lt;/router-view&gt;3&lt;/keep-alive&gt;4&lt;router-view v-if=\"!$router.meta.keepAlive\"&gt;&lt;/router-view&gt;56//router配置7new Router(&#123;8 routes: [9 &#123;10 name: 'a',11 path: '/a',12 component: A,13 meta: &#123;14 keepAlive: true15 &#125;16 &#125;,17 &#123;18 name: 'b',19 path: '/b',20 component: B21 &#125;22 ]23&#125;) keep-alive 生命周期和新属性生命周期被包含在 `` 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated activated 在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次keep-alive激活时被调用。 deactivated 在组件被停用时调用。 注意：只有组件被 keep-alive 包裹时，这两个生命周期才会被调用，如果作为正常组件使用，是不会被调用，以及在 2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 keep-alive 中，这两个钩子依然不会被调用！另外在服务端渲染时此钩子也不会被调用的。 新属性在vue 2.1.0 版本之后，keep-alive 新加入了两个属性: include(包含的组件缓存生效) 与 exclude(排除的组件不缓存，优先级大于include) 。 include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示 当使用正则或者是数组时，一定要使用 v-bind ! 1&lt;!-- 逗号分隔字符串，只有组件a与b被缓存。这样使用场景变得更有意义了 --&gt;2&lt;keep-alive include=\"a,b\"&gt;3 &lt;component :is=\"view\"&gt;&lt;/component&gt;4&lt;/keep-alive&gt;56&lt;!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) --&gt;7&lt;keep-alive :include=\"/a|b/\"&gt;8 &lt;component :is=\"view\"&gt;&lt;/component&gt;9&lt;/keep-alive&gt;1011&lt;!-- Array (需要使用 v-bind，被包含的都会被缓存) --&gt;12&lt;keep-alive :include=\"['a', 'b']\"&gt;13 &lt;component :is=\"view\"&gt;&lt;/component&gt;14&lt;/keep-alive&gt; 有了include之后，再与 router-view 一起使用时便方便许多了: 1&lt;!-- 一个include解决了，不需要多写一个标签，也不需要在路由元中添加keepAlive了 --&gt;2&lt;keep-alive include='a'&gt;3 &lt;router-view&gt;&lt;/router-view&gt;4&lt;/keeo-alive&gt; 注意 keeo-alive先匹配被包含组件的 name 字段，如果 name 不可用，则匹配当前组件 components 配置中的注册名称。 keeo-alive不会在函数式组件中正常工作，因为它们没有缓存实例。 当匹配条件同时在 include 与 exclude 存在时，以 exclude 优先级最高(当前vue 2.4.2 version)。比如：包含于排除同时匹配到了组件A，那组件A不会被缓存。 包含在 keeo-alive 中，但符合 exclude ，不会调用activated 和 deactivated。 设置了keep-alive,这个时候不会触发生命周期的钩子函数。 当页面内的数据没有发生变化时，页面内的操作比如跳转到另一个路由，是不会去经过生命周期函数的，比如：desdtroy函数等。 它会直接在进入的时候触发activated 和离开的时候触发 deactivated。 所以，如果是有涉及到之前放入mouted周期中的函数，可以将其放入activated，放入desdtroy周期的函数可以放入deactivated。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://lenmon54231.github.io.git/tags/vue/"},{"name":"优化","slug":"优化","permalink":"http://lenmon54231.github.io.git/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"常用点记录（ES6/flex/vue写法)","slug":"常用点记录（ES6flexvue写法)","date":"2020-03-02T09:16:26.000Z","updated":"2020-07-03T07:42:31.160Z","comments":true,"path":"2020/03/02/常用点记录（ES6flexvue写法)/","link":"","permalink":"http://lenmon54231.github.io.git/2020/03/02/%E5%B8%B8%E7%94%A8%E7%82%B9%E8%AE%B0%E5%BD%95%EF%BC%88ES6flexvue%E5%86%99%E6%B3%95)/","excerpt":"常用点记录（ES6/flex/vue写法)ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。 ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。","text":"常用点记录（ES6/flex/vue写法)ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。 ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。 CLASS类的特性在ES5中，没有直接定义类这个功能，一般都是通过构造函数模拟去实现类的功能。ES5实现继承如下： 通过call实现继承： 12 样式或者vue中写法的记录问题贴这个里主要是关于样式中的坑和vue中一些特定写法的记录，统一放入这个帖子中，方便查询 vue中直接在style中进行判断根据条件的不同，在style中判断，然后显示不同的样式 写法如下： 1&lt;el-tag :style=\"'backgroundColor:white;marginLeft:20px;border:none;marginRight:20px;fontSize:14px;color:'+ (isEdit == true ? 'black': 'lightgrey') +''\"2&gt;是否续订:&lt;/el-tag&gt; 外部用“”，内部还需要用‘’包裹，然后再内部使用拼接的写法，同时判断这个条件，还需要用括号包裹起来，并且，对应的值，也需要用‘’包裹起来。 Array.apply(null, { length: 20 }) 和 new Array(20)1render: function (createElement) &#123;2 return createElement('div',3 Array.apply(null, &#123; length: 20 &#125;).map(function () &#123;4 return createElement('p', 'hi')5 &#125;)6 )7&#125; Array.apply(null, { length: 20 }) 生成的数组形式为[undifiend,undifiend,undifiend,…..], new Array(20)等价于[，，，，] 后面使用.map方法的时候，map方法的限制为：map函数并不会遍历数组中没有初始化或者被delete的元素（有相同限制还有forEach, reduce方法）。 而new Array 并没有初始化。 所以，需要采用官方的写法。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://lenmon54231.github.io.git/tags/ES6/"},{"name":"新特性","slug":"新特性","permalink":"http://lenmon54231.github.io.git/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"E","slug":"初始模板","date":"2020-01-02T09:16:26.000Z","updated":"2020-05-15T01:41:18.463Z","comments":true,"path":"2020/01/02/初始模板/","link":"","permalink":"http://lenmon54231.github.io.git/2020/01/02/%E5%88%9D%E5%A7%8B%E6%A8%A1%E6%9D%BF/","excerpt":"关这个","text":"关这个","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://lenmon54231.github.io.git/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://lenmon54231.github.io.git/tags/github/"}]},{"title":"ElementUI的使用","slug":"ElementUI的使用","date":"2020-01-02T09:16:26.000Z","updated":"2020-08-13T06:55:42.641Z","comments":true,"path":"2020/01/02/ElementUI的使用/","link":"","permalink":"http://lenmon54231.github.io.git/2020/01/02/ElementUI%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"ElementUI的使用记录ElementUI的入门-组件的使用记录常用的组件，如Form，Tabs，Table等使用，还有一些常用的使用情况也会记录","text":"ElementUI的使用记录ElementUI的入门-组件的使用记录常用的组件，如Form，Tabs，Table等使用，还有一些常用的使用情况也会记录 elementUI的级联器懒加载三级联动典型的级联器代码： 1&lt;div class=\"block\"&gt;2 &lt;el-cascader3 v-model=\"editMallInfo.addressCode\"4 :props=\"props\"5 :options=\"options\"6 @change=\"handleChange\"7 :placeholder=\"addressCodePlaceholder\"8 &gt;&lt;/el-cascader&gt;9 &lt;/div&gt; 1data() &#123;2 return &#123;3 props: &#123;4 lazy: true,5 lazyLoad(node, resolve) &#123;6 let nodes = [];7 const &#123; level, root, value &#125; = node;8 if (node.level == 1) &#123;9 api.citysByProvinceCode(&#123; provinceCode: node.value &#125;).then(res =&gt; &#123;10 const nodes = Array.from(res.data).map(item =&gt; &#123;11 return &#123;12 value: item.areaCode,13 label: item.areaName,14 leaf: level &gt;= 215 &#125;;16 &#125;);17 // 通过调用resolve将子节点数据返回，通知组件数据加载完成18 resolve(nodes);19 &#125;, 1000);20 &#125; else if (node.level == 2) &#123;21 api.districtByCityCode(&#123; cityCode: node.value &#125;).then(res =&gt; &#123;22 const nodes = Array.from(res.data).map(item =&gt; &#123;23 return &#123;24 value: item.areaCode,25 label: item.areaName,26 leaf: level &gt;= 227 &#125;;28 &#125;);29 resolve(nodes);30 &#125;, 1000);31 &#125;32 &#125;33 &#125;,34 options: []35 &#125;36&#125; 1getCityAndProvice() &#123;2 api3 .allProvince()4 .then(res =&gt; &#123;5 for (let i = 0; i &lt; res.data.length; i++) &#123;6 res.data[i].label = res.data[i].areaName;7 res.data[i].value = res.data[i].areaCode;8 this.options.push(res.data[i]);9 &#125;10 &#125;)11 .catch();12&#125;, 通过控制prop中的leaf: level &gt;= 2，来判断是否需要加载下一级。 关于el-form的清除表单数据的坑代码： 1this.$nextTick(() =&gt; &#123;2 this.$refs[\"SecondLevelform\"].resetFields();3&#125;); 清空表单有时候会在页面报错，因为找不到对应的dom，所以需要再dom下一次更新后，再清除。 Form的使用典型的表单1 &lt;el-form2 :inline=\"true\"3 ref=\"searchForm\"4 :model=\"searchForm\"5 :rules=\"rules\"6 @keyup.enter.native=\"loadTableData\"7 &gt;8 &lt;el-form-item label=\"日期筛选\"&gt;9 &lt;el-date-picker10 v-model=\"dateRange\"11 type=\"daterange\"12 range-separator=\"至\"13 clearable14 unlink-panels15 start-placeholder=\"开始日期\"16 end-placeholder=\"结束日期\"17 value-format=\"yyyy-MM-dd\"18 &gt;&lt;/el-date-picker&gt;19 &lt;/el-form-item&gt;20 &lt;el-form-item label=\"商品ID\" prop=\"goodsId\"&gt;21 &lt;el-input v-model=\"searchForm.goodsId\" clearable placeholder=\"请输入\"&gt;&lt;/el-input&gt;22 &lt;/el-form-item&gt;23 &lt;el-form-item label=\"sku编号\" prop=\"specsId\"&gt;24 &lt;el-input v-model=\"searchForm.specsId\" clearable placeholder=\"请输入\"&gt;&lt;/el-input&gt;25 &lt;/el-form-item&gt;26 &lt;el-form-item label=\"商品类型\" prop=\"goodsTypeId\"&gt;27 &lt;el-select v-model=\"searchForm.goodsTypeId\" clearable placeholder=\"请输入\" class=\"m_r_10\"&gt;28 &lt;el-option label=\"电子券商品\" value=\"0\"&gt;&lt;/el-option&gt;29 &lt;el-option label=\"虚拟商品\" value=\"2\"&gt;&lt;/el-option&gt;30 &lt;el-option label=\"实物商品\" value=\"1\"&gt;&lt;/el-option&gt;31 &lt;/el-select&gt;32 &lt;/el-form-item&gt;33 &lt;el-form-item label=\"订单号\" prop=\"orderId\"&gt;34 &lt;el-input clearable v-model=\"searchForm.orderId\" placeholder=\"请输入\"&gt;35 &lt;i slot=\"prefix\" class=\"el-input__icon el-icon-search\"&gt;&lt;/i&gt;36 &lt;/el-input&gt;37 &lt;/el-form-item&gt;38 &lt;el-form-item&gt;39 &lt;el-button @click=\"handleClickResetSearch\"&gt;重置&lt;/el-button&gt;40 &lt;el-button type=\"primary\" @click=\"handleClickSarch\"&gt;查询&lt;/el-button&gt;41 &lt;/el-form-item&gt;42 &lt;/el-form&gt;43&lt;script&gt;44 export default &#123;45 data() &#123;46 return &#123;47 dateRange: \"\",48 searchForm: &#123;49 orderId: null,50 brandId: null,51 goodsTypeId: null,52 specsId: null,53 goodsId: null54 &#125;,55 rules: &#123;56 goodsId: [57 &#123; required: true, message: '请输入商品ID', trigger: 'blur' &#125;,58 &#123; min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' &#125;59 ],60 specsId: [&#123; required: true, validator: this.validateNumber, trigger: \"change\" &#125;]61 &#125;,62 activeName: \"first\"63 &#125;;64 &#125;,65 methods: &#123;66 onSubmit() &#123;67 console.log('submit!');68 &#125;69 &#125;70 &#125;71&lt;/script&gt; 基本构成 外层： 内部： Form上的关键值 ref：用在获取这个form的元素后做一些操作，比如resetFields（清空） this.$refs[“searchForm”].resetFields(); :model:”表单数据对象”，这个实际上是表单内的各种选项的数据集合，比如你的item内选择了name，region等等。主要是为了rules去验证其内容。 :rules:校验规则， 提供普通校验规则： goodsId: [ { required: true, message: &apos;请输入商品ID&apos;, trigger: &apos;blur&apos; }, { min: 3, max: 5, message: &apos;长度在 3 到 5 个字符&apos;, trigger: &apos;blur&apos; } ], 提供自定义校验规则： 1data() &#123;2 return &#123;3 rules: &#123;4 goodsId: [5 &#123; required: true, message: '请输入商品ID', trigger: 'blur' &#125;,6 &#123; min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' &#125;7 ],8 &#125;9 &#125;10&#125; 1methods: &#123;2 validateNumber(event,data,callback)&#123;3 if(data &gt; 2)&#123;4 callback(new Error(\"数字大于2\"))5 &#125;else&#123;6 callback(new Error(\"数字小于等于2\"))7 &#125;8 &#125;9&#125; inline:表单域变为行内的表单域，就是将表单内的item变为一行显示，通过inline-block的形式。 Form上的方法 validate：对整个表单进行检验,valid为true则校验成功 1this.$refs[\"searchForm\"].validate(valid =&gt; &#123;2 conso.log(valid)3&#125;) validateField:对表单的一部分进行校验 一般使用场景为：比如填写了密码后，需要填写二次密码，那么填写二次密码之后，可以直接通过validateField校验第一次的密码 1this.$refs[\"searchForm\"].validateField('goodsId'); resetFields:清空。 clearValidate：移除表单项的校验结果。 Form-item上的常用关键值 prop：表单域 model 字段，类似于item的名字，可以用来区分不同的item label：显示文本 required:该item是否是必须填写的 Form-item上的方法 resetField:同上 clearValidata:同上 Tabs的使用典型使用1&lt;template&gt;2 &lt;el-tabs v-model=\"activeName\" @tab-click=\"handleClick\"&gt;3 &lt;el-tab-pane label=\"用户管理\" name=\"first\"&gt;用户管理&lt;/el-tab-pane&gt;4 &lt;el-tab-pane label=\"配置管理\" name=\"second\"&gt;配置管理&lt;/el-tab-pane&gt;5 &lt;el-tab-pane label=\"角色管理\" name=\"third\"&gt;角色管理&lt;/el-tab-pane&gt;6 &lt;el-tab-pane label=\"定时任务补偿\" name=\"fourth\"&gt;定时任务补偿&lt;/el-tab-pane&gt;7 &lt;/el-tabs&gt;8&lt;/template&gt;9&lt;script&gt;10 export default &#123;11 data() &#123;12 return &#123;13 activeName: 'second'14 &#125;;15 &#125;,16 methods: &#123;17 handleClick(tab, event) &#123;18 console.log(tab, event);19 &#125;20 &#125;21 &#125;;22&lt;/script&gt; 典型结构1&lt;el-tabs v-model&#x3D;&quot;activeName&quot; @tab-click&#x3D;&quot;handleClick&quot;&gt;2&lt;el-tab-pane label&#x3D;&quot;用户管理&quot; name&#x3D;&quot;first&quot;&gt;用户管理&lt;&#x2F;el-tab-pane&gt;3&lt;&#x2F;el-tabs&gt; Tabs上的关键值 value / v-model：选中选项卡的 name type closable addable tab-position stretch table的使用典型使用1&lt;el-table2 :data=\"tableData\"3 border4 style=\"width: 100%\"&gt;5 &lt;el-table-column6 prop=\"date\"7 label=\"日期\"8 width=\"180\"&gt;9 &lt;/el-table-column&gt;10 &lt;el-table-column11 prop=\"name\"12 label=\"姓名\"13 width=\"180\"&gt;14 &lt;/el-table-column&gt;15 &lt;el-table-column16 prop=\"address\"17 label=\"地址\"&gt;18 &lt;/el-table-column&gt;19&lt;/el-table&gt; 特征值 border fit Slot !important典型使用1&lt;template slot-scope=\"scope\"&gt;2 &lt;div v-for=\"item in scope.row.goodsInfo\"&gt; 3 &lt;span v-if=\"item.goodsTypeId === 0\"&gt;电子券&lt;/span&gt;4 &lt;span v-if=\"item.goodsTypeId === 1\"&gt;实物商品&lt;/span&gt;5 &lt;span v-if=\"item.goodsTypeId === 2\"&gt;虚拟商品&lt;/span&gt;6 &lt;/div&gt;7 &lt;/template&gt; 使用场景 广泛的适用于各类form，tables中，其用法实现根据父级对象传值来显示不同的子集元素内容 template中使用 slot-scope， 模板内部通过 scope.row 去调用父级对象传过来的值 动态循环el-table需求table的第一行渲染，要根据接口的返回值，来动态的生成，并且要匹配到对应的位置。 实现需要两个接口返回数据： 1.需要返回第一行的数据 2.返回table中的具体数据 返回格式如下： 1[&#123;name: \"中餐\", id: 9&#125;, &#123;name: \"西餐\", id: 11&#125;, &#123;name: \"小吃快餐\", id: 263&#125;, &#123;name: \"火锅\", id: 264&#125;,…] 1[&#123;11: 1, 263: 1, 264: 3, 471: 3, 472: 1, orderBySign: 1597161600000, x: \"2020-08-12\"&#125;,…] 对象的name用来渲染到table上，id则使用来匹配具体的数据。id对应的value即是table数据的key el-table的渲染如下： 1&lt;el-table2 v-loading=\"tableLoading\"3 :data=\"finaListSigle\"4 border5 class=\"table\"6 ref=\"multipleTable\"7&gt;8 &lt;el-table-column label=\"日期\"&gt;9 &lt;template slot-scope=\"scope\"&gt;10 &lt;div&gt;&#123;&#123;scope.row.x&#125;&#125;&lt;/div&gt;11 &lt;/template&gt;12 &lt;/el-table-column&gt;13 &lt;el-table-column14 v-for=\"(info,index) in twoTableTitle\"15 :key=\"index\"16 :property=\"info.id\"17 :label=\"info.name\"18 &gt;19 &lt;template slot-scope=\"scope\"&gt;20 &lt;div&gt;&#123;&#123;scope.row[scope.column.property]&#125;&#125;&lt;/div&gt;21 &lt;/template&gt;22 &lt;/el-table-column&gt;23&lt;/el-table&gt; 核心主要实现的逻辑是，如何将对应的key放到slot的插槽中去。具体代码如下： 1 :property=\"info.id\"2&lt;div&gt;&#123;&#123;scope.row[scope.column.property]&#125;&#125;&lt;/div&gt;","categories":[],"tags":[{"name":"ElementUI","slug":"ElementUI","permalink":"http://lenmon54231.github.io.git/tags/ElementUI/"},{"name":"form，tabs","slug":"form，tabs","permalink":"http://lenmon54231.github.io.git/tags/form%EF%BC%8Ctabs/"},{"name":"table","slug":"table","permalink":"http://lenmon54231.github.io.git/tags/table/"}]},{"title":"Hexo链接网络图片不显示","slug":"hexo图片不显示","date":"2019-12-02T09:16:26.000Z","updated":"2020-07-03T08:03:07.773Z","comments":true,"path":"2019/12/02/hexo图片不显示/","link":"","permalink":"http://lenmon54231.github.io.git/2019/12/02/hexo%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/","excerpt":"Hexo图片不显示问题博客内需要引用一些图片，使用的是阿里云Oss，图片设置的公共读，图片地址从浏览器打开可以直接访问，但是博客内引用不能显示。 在chrome浏览器中检查会发现有403的错误","text":"Hexo图片不显示问题博客内需要引用一些图片，使用的是阿里云Oss，图片设置的公共读，图片地址从浏览器打开可以直接访问，但是博客内引用不能显示。 在chrome浏览器中检查会发现有403的错误 解决方法方法其实很简单，只需要文章的头部如下图所示位置添加这一句话就可以完美解决问题 referrer是什么&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt; referrer是用于追踪用户是从哪个页面跳转过来，js中使用document.referrer来得到值，一般用户做移动端back按钮，如用户通过别人发送时候链接进入页面时，可以隐藏back按钮。 referrer有五种属性: No Referrer （永远不做记录） No Referrer When Downgrade（浏览器默认，当降级时候不记录，从https跳转到http） Origin Only（只记录 协议+ host） Origin When Cross-origin（仅在发生跨域访问时记录 协议+host） Unsafe URL（永远记录） 参考链接 ：[Referrer Policy 介绍]、document.referrer的用法详解 豆瓣api调用图片403提示豆瓣api需要搭建一个电影类的分类网站，所以会调用到豆瓣的api，现在官方没有给公共的api使用，于是网上找了下有提供备份的api使用，地址如下：豆瓣api 使用这个地址，可以直接访问到豆瓣的内容，但是使用过程中，发现关于电影的名字，类型，上映年份都可以直接访问，只有图片没有办法访问，有提示403错误。 原因豆瓣使用了防盗链： 很多时候别人直接把我们的网站的资源拿去在他们网站展示，但是消费的是我们的流量，为了解决这种问题，才会有防盗链这个思路 这里说的只是一个简单的概念，既使用host和reffer请求头做对比，简单的做一个处理，主要是用来熟悉http头 解决方法在页面中加上 实现了正常的访问！","categories":[],"tags":[{"name":"图片地址","slug":"图片地址","permalink":"http://lenmon54231.github.io.git/tags/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80/"},{"name":"hexo","slug":"hexo","permalink":"http://lenmon54231.github.io.git/tags/hexo/"},{"name":"refer","slug":"refer","permalink":"http://lenmon54231.github.io.git/tags/refer/"}]},{"title":"静态布局、自适应布局、流式布局、响应式布局、弹性布局等的概念和区别","slug":"静态布局、自适应布局、流式布局、响应式布局、弹性布局等的概念和区别","date":"2019-12-02T09:16:26.000Z","updated":"2020-07-03T08:02:38.695Z","comments":true,"path":"2019/12/02/静态布局、自适应布局、流式布局、响应式布局、弹性布局等的概念和区别/","link":"","permalink":"http://lenmon54231.github.io.git/2019/12/02/%E9%9D%99%E6%80%81%E5%B8%83%E5%B1%80%E3%80%81%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E3%80%81%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E3%80%81%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E7%AD%89%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/","excerpt":"静态布局、自适应布局、流式布局、响应式布局、弹性布局等的概念和区别/圣杯布局静态布局 布局特点：不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见与pc端。 布局特点：不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。 常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见与pc端。 优点：这种布局方式对设计师和CSS编写者来说都是最简单的，亦没有兼容性问题。 缺点：显而易见，即不能根据用户的屏幕尺寸做出不同的表现。","text":"静态布局、自适应布局、流式布局、响应式布局、弹性布局等的概念和区别/圣杯布局静态布局 布局特点：不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见与pc端。 布局特点：不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。 常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见与pc端。 优点：这种布局方式对设计师和CSS编写者来说都是最简单的，亦没有兼容性问题。 缺点：显而易见，即不能根据用户的屏幕尺寸做出不同的表现。 流式布局 流式布局（Liquid）的特点（也叫”Fluid”) 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。 网页中主要的划分区域的尺寸使用百分数（搭配min-、max-属性使用），例如，设置网页主体的宽度为80%，min-width为960px。图片也作类似处理（width:100%, max-width一般设定为图片本身的尺寸，防止被拉伸而失真）。 布局和设计 布局特点：屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示】 设计方法：使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。 优点和缺点 按照屏幕分辨率进行适配调整，但整体布局不变。适应早期的web布局，兼容性高 缺点明显：主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即：这些东西无法变得“流式”），显示非常不协调。 自适应布局 自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。 实现方法 使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。 特点 布局特点：屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。 本质上是多个多个静态布局。 响应式布局 可以把响应式布局看作是流式布局和自适应布局设计理念的融合。 响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表、冰箱的Web浏览器等等）都能显示出令人满意的效果，对CSS编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。 设计方法： 媒体查询+流式布局。通常使用 @media 媒体查询 和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。 特点： 每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。 优点和缺点： 适应pc和移动端，如果足够耐心，效果完美 （1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。（2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。需要很多个@media。 代表比如bootstrap，element等都是响应式的设计布局 弹性布局 这类布局的特点是，包裹文字的各元素的尺寸采用em/rem做单位，而页面的主要划分区域的尺寸仍使用百分数或px做单位（同「流式布局」或「静态/固定布局」）。早期浏览器不支持整个页面按比例缩放，仅支持网页内文字尺寸的放大，这种情况下。使用em/rem做单位，可以使包裹文字的元素随着文字的缩放而缩放。 rem,em区别： rem,em都是顺应不同网页字体大小展现而产生的。其中，em是相对其父元素，在实际应用中相对而言会带来很多不便；而rem是始终相对于html大小，即页面根元素。 根据不同的屏幕尺寸，rem改变的是font-size的大小，但是本质上，客户看到的布局是没有改变的，这一点不同于响应式布局。 响应式和弹性布局之间的对比： rem布局：改变浏览器宽度，页面所有元素的高宽都等比例缩放，也就是大屏幕下导航是横的，小屏幕下还是横的只不过变小了。 响应式布局：改变浏览器宽度，“布局”会随之变化，不是一成不变的，例如导航栏在大屏幕下是横排，在小屏幕下是竖排，在超小屏幕下隐藏为菜单，也就是说如果有足够的耐心，在每一种屏幕下都应该有合理的布局，完美的效果。 总结 如果只做pc端，那么静态布局（定宽度）是最好的选择； 如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份css+一份js调节font-size搞定； 如果pc，移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局。 圣杯布局的三种实现圣杯布局和双飞翼布局一直是前端面试的高频考点，圣杯布局的出现是来自由 Matthew Levine 在 2006 年写的一篇文章 《In Search of the Holy Grail》。 比起双飞翼布局，它的起源不是源于对页面的形象表达。在西方，圣杯是表达“渴求之物”的意思。而双飞翼布局则是源于淘宝的UED，可以说是灵感来自于页面渲染。 效果图布局形式如下： header和footer各自占领屏幕所有宽度，高度固定。 中间的container是一个三栏布局。 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。三种实现形式 浮动 设置header，footer高度 #container内部子元素有float浮动，所以会导致一些问题，所以添加了overflow：hidden；实际上也可以使用overflow：auto； container左右两边需要留出左右对应的位置，padding-left: 200px;padding-right: 150px; 给左右元素设置浮动后，脱离文档流。使用margin-left：-100%；和margin-right：-150px定位到对应的位置。 清除浮动参考:清除浮动 1&lt;body&gt;2 &lt;div id=\"header\"&gt;#header&lt;/div&gt;3 &lt;div id=\"container\"&gt;4 &lt;div id=\"center\" class=\"column\"&gt;#center&lt;/div&gt;5 &lt;div id=\"left\" class=\"column\"&gt;#left&lt;/div&gt;6 &lt;div id=\"right\" class=\"column\"&gt;#right&lt;/div&gt;7 &lt;/div&gt;8 &lt;div id=\"footer\"&gt;#footer&lt;/div&gt;9&lt;/body&gt; 1body &#123;2 min-width: 550px; /* 2x leftContent width + rightContent width */3 font-weight: bold;4 font-size: 20px;5&#125;6 7#header, #footer &#123;8 background: rgba(29, 27, 27, 0.726);9 text-align: center;10 height: 60px;11 line-height: 60px;12&#125;13 14#container &#123;15 padding-left: 200px; /* leftContent width */16 padding-right: 150px; /* rightContent width */17 overflow: hidden;18&#125;19 20#container .column &#123;21 position: relative;22 float: left;23 text-align: center;24 height: 300px;25 line-height: 300px;26&#125;27 28#center &#123;29 width: 100%;30 background: rgb(206, 201, 201);31&#125;32 33#left &#123;34 width: 200px; /* leftContent width */35 right: 200px; /* leftContent width */36 margin-left: -100%;37 background: rgba(95, 179, 235, 0.972);38&#125;39 40#right &#123;41 width: 150px; /* rightContent width */42 margin-right: -150px; /* rightContent width */43 background: rgb(231, 105, 2); flex布局 header和footer设置样式，横向撑满。 container中的left、center、right依次排布即可 给container设置弹性布局 display: flex; left和right区域定宽，center设置 flex: 1; 即可 1&lt;body&gt;2 &lt;div id=\"header\"&gt;#header&lt;/div&gt;3 &lt;div id=\"container\"&gt;4 &lt;div id=\"left\" class=\"column\"&gt;#left&lt;/div&gt;5 &lt;div id=\"center\" class=\"column\"&gt;#center&lt;/div&gt;6 &lt;div id=\"right\" class=\"column\"&gt;#right&lt;/div&gt;7 &lt;/div&gt;8 &lt;div id=\"footer\"&gt;#footer&lt;/div&gt;9&lt;/body&gt; 1body &#123;2 min-width: 550px; 3 font-weight: bold;4 font-size: 20px;5&#125;6#header, #footer &#123;7 background: rgba(29, 27, 27, 0.726);8 text-align: center;9 height: 60px;10 line-height: 60px;11&#125;12#container &#123;13 display: flex;14&#125;15#container .column &#123;16 text-align: center;17 height: 300px;18 line-height: 300px;19&#125;20#center &#123;21 flex: 1;22 background: rgb(206, 201, 201);23&#125;24#left &#123;25 width: 200px; 26 background: rgba(95, 179, 235, 0.972);27&#125;28#right &#123;29 width: 150px; 30 background: rgb(231, 105, 2);31&#125; grid布局 如上图所示，我们把body划分成三行四列的网格，其中有5条列网格线 给body元素添加display: grid;属性变成一个grid(网格)给header元素设置grid-row: 1; 和 grid-column: 1/5; 意思是占据第一行网格的从第一条列网格线开始到第五条列网格线结束给footer元素设置grid-row: 1; 和 grid-column: 1/5; 意思是占据第三行网格的从第一条列网格线开始到第五条列网格线结束给left元素设置grid-row: 2; 和 grid-column: 1/2; 意思是占据第二行网格的从第一条列网格线开始到第二条列网格线结束给center元素设置grid-row: 2; 和 grid-column: 2/4; 意思是占据第二行网格的从第二条列网格线开始到第四条列网格线结束给right元素设置grid-row: 2; 和 grid-column: 4/5; 意思是占据第二行网格的从第四条列网格线开始到第五条列网格线结束 1&lt;body&gt;2 &lt;div id=\"header\"&gt;#header&lt;/div&gt;3 &lt;div id=\"left\" class=\"column\"&gt;#left&lt;/div&gt;4 &lt;div id=\"center\" class=\"column\"&gt;#center&lt;/div&gt;5 &lt;div id=\"right\" class=\"column\"&gt;#right&lt;/div&gt;6 &lt;div id=\"footer\"&gt;#footer&lt;/div&gt;7&lt;/body&gt; 1body &#123;2 min-width: 550px;3 font-weight: bold;4 font-size: 20px;5 display: grid;6 &#125;7 #header,8 #footer &#123;9 background: rgba(29, 27, 27, 0.726);10 text-align: center;11 height: 60px;12 line-height: 60px;13 &#125;14 #header &#123;15 grid-row: 1;16 grid-column: 1/5;17 &#125;18 #footer &#123;19 grid-row: 3;20 grid-column: 1/5;21 &#125;22 .column &#123;23 text-align: center;24 height: 300px;25 line-height: 300px;26 &#125;27 #left &#123;28 grid-row: 2;29 grid-column: 1/2;30 background: rgba(95, 179, 235, 0.972);31 &#125;32 #center &#123;33 grid-row: 2;34 grid-column: 2/4;35 background: rgb(206, 201, 201);36 &#125;37 #right &#123;38 grid-row: 2;39 grid-column: 4/5;40 background: rgb(231, 105, 2);41 &#125; 三种实现形式 三种实现形式内，不考虑兼容性的情况下，flex布局是使用比较广的，浮动的布局相对比较麻烦，需要设定各种margin和padding和position的定位，grid布局属于二维布局，就兼容性来说，还是比flex要差一些。 CSS实现文字和图片的水平垂直居中居中是一开始学习使用css遇到比较多的情况，不同的情况有不同的居中方式，随着前端的规范和写法的进步，有各种各样的方法实现，现在来记录一下。主要有文字、div块级元素和图片的居中，以下分几种情况说明。 文字居中 单行文字（多行文字） 水平居中 1text-align：center 垂直居中只要height值等于line-height值就ok 1.son&#123;height:100px;line-height:100px;&#125; 多行文字 垂直居中 高度固定关键属性：display:tabel-cell; vertical-align:middle; 1&lt;style&gt;2div&#123;height:300px;3width:200px;4vertical-align:middle;5display:table-cell;6word-break:break-all;7&#125;8&lt;/style&gt; 父级元素高度固定，子元素为行内元素关键属性：父级:diaplay:tabel; 子集：display:tabel-cell; vertical-align:middle; 1&lt;style&gt;div&#123;height:300px;width:200px;display:table;word-break:break-all;background:#666;2&#125;3span&#123;display:table-cell;vertical-align:middle;4&#125;5&lt;/style&gt;6&lt;div&gt;7&lt;span&gt;some things&lt;/span&gt;8&lt;/div&gt; 父级元素高度固定，子元素为块元素且高度固定关键属性：定位 + margin-top：负值； 1&lt;style type=\"text/css\"&gt;2*&#123;margin:0;padding:0;&#125;3div&#123;height:300px;width:200px;position:relative;word-break:break-all;background:#666;&#125;4p&#123;position:absolute;top:50%;left:0;height:80px;margin-top:-40px;background:red;&#125;5&lt;/style&gt; 6&lt;div&gt;7&lt;p&gt;some things&lt;/p&gt;8&lt;/div&gt; 父级元素高度固定，子元素为块元素且高度不固定关键属性：定位 + transform：translateY(-50%); 1&lt;style&gt;2*&#123;margin:0;padding:0;&#125; /*不加的话会被p或其他标签默认样式影响*/3div&#123;height:300px;width:200px;position:relative; word-break:break-all;background:#666;&#125;4p&#123;position:absolute;top:50%;left:0;transform:translateY(-50%);&#125;/*个人建议，被包裹的块标签就不要height，用内容将高度撑开就好*/5&lt;/style&gt;6&lt;div&gt;7&lt;p&gt;some things&lt;/p&gt;8&lt;/div&gt; 父子元素高度均固定关键属性：定位 + margin：auto； 1&lt;style&gt;2*&#123;margin:0;padding:0;&#125;3div&#123;height:300px;width:400px;position:relative;word-break:break-all;background:#666;&#125;4p&#123;position:absolute;top:0;bottom:0;right:0;left:0;margin:auto;height:80px;width:200px;background:red;&#125;5&lt;/style&gt;6&lt;div&gt;7&lt;p&gt;some things&lt;/p&gt;8&lt;/div&gt; 块级元素居中 水平居中 行内元素(inline 或 inline-* 元素)此类元素需要水平居中，则父级元素必须是块级元素(block level)，且父级元素上需要这样设置样式： 1.parent &#123;2 text-align: center;3&#125; 块级元素块级元素水平居中，需要设置 margin-left 和 margin-right 为 auto，且需要显示设置宽度，不然就占满整行，就无所谓水平居中了。 1.block &#123;2 width: 300px;3 margin: 0 auto;4&#125; 同一行多个块级元素如果是在同一行里需要居中多个块级元素，可以尝试下面的两种方法： 1/* 方法一 */2.parent &#123;3 text-align: center;4&#125;5.parent div &#123;6 display: inline-block;7&#125;8/* 方法二 */9.parent &#123;10 display: -webkit-box;11 display: -ms-flexbox;12 display: flex;13 -webkit-box-pack: center;14 -ms-flex-pack: center;15 justify-content: center;16&#125; 垂直居中 元素高度已知知道块元素的高度，那么使用绝对定位和负的 margin 即可实现垂直居中： 1.parent &#123;2 position: relative;3&#125;4.parent div &#123;5 position: absolute;6 top: 50%;7 height: 50px;8 margin-top: -25px;9&#125; 块级元素高度是可变的这个时候就需要用 transform 的Y轴平移来实现了： 1.parent &#123;2 position: relative;3&#125;4.parent div &#123;5 position: absolute;6 top: 50%;7 transform: translateY(-50%);8&#125; flexbox布局flex主要是考虑布局问题 1.parent &#123;2 display: flexbox;3 justify-content: center;4 flex-direction: column;5&#125; 块级元素高度不是固定的，且不由内容决定 1.parent &#123;2 position: relative;3&#125;4.parent div &#123;5 position: absolute;6 top: 30%;7 bottom: 30%; 8&#125; 水平垂直居中 知道宽高的盒子 1.parent &#123;2 position: realtive;3&#125;4.parent div &#123;5 width: 300px;6 height: 300px;7 posotion: absoltue;8 left: 50%;9 top: 50%;10 margin-left: -150px;11 margin-top: -150px;12&#125; 不知道宽高的盒子 1.parent &#123;2 position: realtive;3&#125;4.parent div &#123;5 posotion: absoltue;6 left: 50%;7 top: 50%;8 transform: translate(-50%, -50%); 9&#125; flex布局 1.parent &#123;2 display: flex;3 justify-content: center;4 align-items: center;5&#125; flex设置成1和auto有什么区别flex的取值首先明确一点是， flex 是 flex-grow、flex-shrink、flex-basis的缩写。flex 的默认值是以上三个属性值的组合。 那么，flex：1；和flex：auto；有对应的全写如下： 1.item &#123;flex: auto;&#125; 1.item &#123;2 flex-grow: 1;3 flex-shrink: 1;4 flex-basis: auto;5&#125; 1.item &#123;flex: 1;&#125; 1.item &#123;2 flex-grow: 1;3 flex-shrink: 1;4 flex-basis: 0%;5&#125; 这三个缩写代表什么意思呢？ flex-shrink属性指定了flex元素的收缩规则。flex元素仅在交替宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据flex-shrink的值。 flex-grow属性用于设置或检索弹性盒子的扩展比率。 flex-basis 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。flex-basis 规定的范围取决于 box-sizing。这里主要讨论以下 flex-basis 的取值情况： auto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。 content：指根据该子元素的内容自动布局。有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto。 百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。 举个例子1&lt;div class=\"parent\"&gt;2 &lt;div class=\"item-1\"&gt;&lt;/div&gt;3 &lt;div class=\"item-2\"&gt;&lt;/div&gt;4 &lt;div class=\"item-3\"&gt;&lt;/div&gt;5&lt;/div&gt; 1&lt;style type=\"text/css\"&gt;2 .parent &#123;3 display: flex;4 width: 600px;5 &#125;6 .parent &gt; div &#123;7 height: 100px;8 &#125;9 .item-1 &#123;10 width: 140px;11 flex: 2 1 0%;12 background: blue;13 &#125;14 .item-2 &#123;15 width: 100px;16 flex: 2 1 auto;17 background: darkblue;18 &#125;19 .item-3 &#123;20 flex: 1 1 200px;21 background: lightblue;22 &#125;23&lt;/style&gt; 子元素的总基准值是：.item-1:0% + item-2:auto + .item-3:200px = 300px，其中 1- 0% 即 0 宽度2- auto 对应取主尺寸即 100px 故剩余空间为 600px - 300px = 300px 有剩余空间，需要分配剩余空间，需要flex-grow，就是flex:2,lex:2,lex:1; 剩余空间分配如下： 1- item-1 和 item-2 各分配 2&#x2F;5，各得 120px2- item-3 分配 1&#x2F;5，得 60px 各项目最终宽度为： 1- item-1 &#x3D; 0% + 120px &#x3D; 120px2- item-2 &#x3D; auto + 120px &#x3D; 220px3- item-3 &#x3D; 200px + 60px &#x3D; 260px 注意 当 item-1 基准值取 0% 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 140px，也并没有什么用，形同虚设 而 item-2 基准值取 auto 的时候，根据规则基准值使用值是主尺寸值即 100px，故这 100px 不会纳入剩余空间 全部设置1.item &#123;flex: 2333 3222 234px;&#125;2.item &#123;3 flex-grow: 2333;4 flex-shrink: 3222;5 flex-basis: 234px;6&#125; 当 flex 取值为 none，则计算值为 0 0 auto，如下是等同的： 1.item &#123;flex: none;&#125;2.item &#123;3 flex-grow: 0;4 flex-shrink: 0;5 flex-basis: auto;6&#125; 当 flex 取值为 auto，则计算值为 1 1 auto，如下是等同的： 1.item &#123;flex: auto;&#125;2.item &#123;3 flex-grow: 1;4 flex-shrink: 1;5 flex-basis: auto;6&#125; 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的： 1.item &#123;flex: 1;&#125;2.item &#123;3 flex-grow: 1;4 flex-shrink: 1;5 flex-basis: 0%;6&#125; 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）： 1.item-1 &#123;flex: 0%;&#125;2.item-1 &#123;3 flex-grow: 1;4 flex-shrink: 1;5 flex-basis: 0%;6&#125;7.item-2 &#123;flex: 24px;&#125;8.item-1 &#123;9 flex-grow: 1;10 flex-shrink: 1;11 flex-basis: 24px;12&#125; 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的： 1.item &#123;flex: 2 3;&#125;2.item &#123;3 flex-grow: 2;4 flex-shrink: 3;5 flex-basis: 0%;6&#125; 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的： 1.item &#123;flex: 2333 3222px;&#125;2.item &#123;3 flex-grow: 2333;4 flex-shrink: 1;5 flex-basis: 3222px;6&#125; 移动端优先和桌面端优先什么是“移动端优先”和“桌面优先”方法构建响应式网站是如今前端开发者的必备技能，当我们谈到响应式网站时，“移动端优先”这个词立刻就会出现在脑海中。 我们知道从“移动端优先”这个角度开始设计很重要，但我们很少谈到使用“移动端优先”的方法来写代码。 今天，我想与你分享“移动端优先”添加样式的方法，为什么这种方法更好，以及如何发挥它的魔力。 移动端优先和桌面端优先 区别“移动端优先”添加样式的方法指的是首先在移动设备上应用样式，然后通过媒体查询在样式表中加入应用于大屏幕的高级样式和其他覆盖样式。 这个方法使用min-width媒体查询。 1// 这个样式在0px到600px应用2body &#123; background: red; &#125;34// 这个样式在大于600px时应用5@media (min-width: 600px) &#123;6 body &#123; background: green; &#125;7&#125; 另一方面，“桌面优先”添加样式的方法指的是首先在桌面设备上应用样式，然后通过媒体查询在样式表中加入应用于小屏幕的高级样式和其他覆盖样式。 这个方法使用max-width媒体查询。 1// 这个样式在大于600px时应用2body &#123; background: green; &#125;34// 这个样式在0px到600px应用5@media (max-width: 600px) &#123;6 body &#123; background: red; &#125;7&#125; 为什么是移动端优先？ 为大屏幕编写的代码通常会比为小屏幕编写的代码更复杂，所以编写“移动端优先”代码可以简化你的代码。 设想这样一个场景，你的网站有一个“内容-边栏”布局，.content在移动端占会100%的宽度，在桌面则占60%的宽度。 移动端代码为： 1.content &#123;2 // 为小屏幕设置属性3 // 这里不需要设置任何属性，因为我们可以使用默认样式45 // 为大屏幕设置属性6 @media (min-width: 800px) &#123;7 float: left;8 width: 60%;9 &#125;10&#125; 桌面端代码： 1.content &#123;2 // 为大屏幕设置属性3 float: left;4 width: 60%;56 // 为小屏幕设置属性7 // 注意我们需要重写两个默认属性才能使这个布局正常显示8 @media (max-width: 800px) &#123;9 float: none;10 width: 100%;11 &#125;12&#125; 这里的主要区别就是移动端的布局更多的情况是占用屏幕较大的布局，比如都是100%的占用，可以通过继承直接生成对应的布局。 结合max-width去使用 当你的样式再不同的尺寸下都都不同的显示效果时，也可以通过max-width去终止之前尺寸的布局，节省后续布局的操作。 1.gallery__item &#123;2 float: left;3 margin-right: 5%;4 margin-bottom: 5%;5 @media (max-width: 800px) &#123;6 width: 30%;7 &amp;:nth-child(3n) &#123;8 margin-right: 0;9 &#125;10 &#125;1112 // min-width和max-width查询结合使用13 @media (min-width: 800px) and (max-width: 1200px) &#123;14 width: 21.25%; // (100% - 15%) / 415 &amp;:nth-child(4n) &#123;16 margin-right: 0;17 &#125;18 &#125;1920 @media (min-width: 1200px) &#123;21 width: 16%; // (100% - 20%) / 522 &amp;:nth-child(5n) &#123;23 margin-right: 0;24 &#125;25 &#125;26&#125; 总结建立响应式网站时，min-width媒体查询非常有用，因为它减低了代码复杂度。不过，从上面的例子中可以看出，min-width查询并非所有问题的解决方案，有时在样式表中使用max-width查询也是有益的，它能帮助你保持代码更DRY。 移动端常用的meta标签meta标签记录记录一下常用的meta标签 1&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;2&lt;html lang=\"zh-cmn-Hans\"&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;3&lt;head&gt;4 &lt;!-- 声明文档使用的字符编码 --&gt;5 &lt;meta charset='utf-8'&gt;6 &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;7 &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt;8 &lt;!-- 页面描述 --&gt;9 &lt;meta name=\"description\" content=\"不超过150个字符\"/&gt;10 &lt;!-- 页面关键词 --&gt;11 &lt;meta name=\"keywords\" content=\"\"/&gt;12 &lt;!-- 网页作者 --&gt;13 &lt;meta name=\"author\" content=\"name, email@gmail.com\"/&gt;14 &lt;!-- 搜索引擎抓取 --&gt;15 &lt;meta name=\"robots\" content=\"index,follow\"/&gt;16 &lt;!-- 为移动设备添加 viewport --&gt;17 &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt;18 &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt;19 20 &lt;!-- iOS 设备 begin --&gt;21 &lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt;22 &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;23 &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/&gt;24 &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt;25 26 &lt;meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"&gt;27 &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt;28 &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/&gt;29 &lt;!-- 设置苹果工具栏颜色 --&gt;30 &lt;meta name=\"format-detection\" content=\"telphone=no, email=no\"/&gt;31 &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;32 &lt;!-- 启用360浏览器的极速模式(webkit) --&gt;33 &lt;meta name=\"renderer\" content=\"webkit\"&gt;34 &lt;!-- 避免IE使用兼容模式 --&gt;35 &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;36 &lt;!-- 不让百度转码 --&gt;37 &lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /&gt;38 &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;39 &lt;meta name=\"HandheldFriendly\" content=\"true\"&gt;40 &lt;!-- 微软的老式浏览器 --&gt;41 &lt;meta name=\"MobileOptimized\" content=\"320\"&gt;42 &lt;!-- uc强制竖屏 --&gt;43 &lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;44 &lt;!-- QQ强制竖屏 --&gt;45 &lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;46 &lt;!-- UC强制全屏 --&gt;47 &lt;meta name=\"full-screen\" content=\"yes\"&gt;48 &lt;!-- QQ强制全屏 --&gt;49 &lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;50 &lt;!-- UC应用模式 --&gt;51 &lt;meta name=\"browsermode\" content=\"application\"&gt;52 &lt;!-- QQ应用模式 --&gt;53 &lt;meta name=\"x5-page-mode\" content=\"app\"&gt;54 &lt;!-- windows phone 点击无高光 --&gt;55 &lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt;56 &lt;!-- iOS 图标 begin --&gt;57 &lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/&gt;58 &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;59 &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/&gt;60 &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;61 &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/&gt;62 &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;63 &lt;!-- iOS 图标 end --&gt;64 65 &lt;!-- iOS 启动画面 begin --&gt;66 &lt;link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/&gt;67 &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;68 &lt;link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/&gt;69 &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;70 &lt;link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/&gt;71 &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;72 &lt;link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/&gt;73 &lt;!-- iPad 横屏 2048x1496（Retina） --&gt;74 75 &lt;link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/&gt;76 &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt;77 &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/&gt;78 &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt;79 &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/&gt;80 &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt;81 &lt;!-- iOS 启动画面 end --&gt;82 83 &lt;!-- iOS 设备 end --&gt;84 &lt;meta name=\"msapplication-TileColor\" content=\"#000\"/&gt;85 &lt;!-- Windows 8 磁贴颜色 --&gt;86 &lt;meta name=\"msapplication-TileImage\" content=\"icon.png\"/&gt;87 &lt;!-- Windows 8 磁贴图标 --&gt;88 89 &lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/&gt;90 &lt;!-- 添加 RSS 订阅 --&gt;91 &lt;link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/&gt;92 &lt;!-- 添加 favicon icon --&gt;9394 &lt;!-- sns 社交标签 begin --&gt;95 &lt;!-- 参考微博API --&gt;96 &lt;meta property=\"og:type\" content=\"类型\" /&gt;97 &lt;meta property=\"og:url\" content=\"URL地址\" /&gt;98 &lt;meta property=\"og:title\" content=\"标题\" /&gt;99 &lt;meta property=\"og:image\" content=\"图片\" /&gt;100 &lt;meta property=\"og:description\" content=\"描述\" /&gt;101 &lt;!-- sns 社交标签 end --&gt;102 103 &lt;title&gt;标题&lt;/title&gt;104&lt;/head&gt;","categories":[],"tags":[{"name":"自适应布局","slug":"自适应布局","permalink":"http://lenmon54231.github.io.git/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"},{"name":"响应式布局，弹性布局","slug":"响应式布局，弹性布局","permalink":"http://lenmon54231.github.io.git/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%EF%BC%8C%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/"}]},{"title":"记录网站功能","slug":"记录网站功能实现","date":"2019-12-02T09:16:26.000Z","updated":"2020-07-03T07:40:14.394Z","comments":true,"path":"2019/12/02/记录网站功能实现/","link":"","permalink":"http://lenmon54231.github.io.git/2019/12/02/%E8%AE%B0%E5%BD%95%E7%BD%91%E7%AB%99%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","excerpt":"记录网站功能网站登录页面和注册页面登录页面和注册页面都做了一个css效果，中间有遇到些问题，记录 点击后会让input框中的文字位置上浮，实现动态的效果，如下：","text":"记录网站功能网站登录页面和注册页面登录页面和注册页面都做了一个css效果，中间有遇到些问题，记录 点击后会让input框中的文字位置上浮，实现动态的效果，如下： 实现代码实现效果是很简单的，代码如下： 1&lt;div class=\"accAndPass\" v-for=\"(item,index) in items1\" :key=\"index\"&gt;2 &lt;span class&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;3 &lt;input name=\"inputValue\" type=\"text\" @focus=\"turnUp(index)\" @blur=\"turnOff(index)\" /&gt;4 &lt;img :src=\"closeIcon\" name='eyes' @click='showPassWord'&gt;5&lt;/div&gt; 当input聚焦的时候添加一个class，失焦的时候去掉这个class即可： 1turnUp(index) &#123;2 var spans = document.getElementsByTagName(\"span\");3 var Bottomsoild = document.getElementsByClassName(\"accAndPass\");4 spans[index].classList.add(\"showup\");5 Bottomsoild[index].classList.add(\"bottom\");6&#125;,7turnOff(index) &#123;8 var Bottomsoild = document.getElementsByClassName(\"accAndPass\");9 var spans = document.getElementsByTagName(\"span\");10 var input_Value = document.getElementsByName(\"inputValue\");11 if (input_Value[index].value !== \"\") &#123;12 spans[index].classList.add(\"showup\");13 Bottomsoild[index].classList.add(\"bottom\");14 &#125; else &#123;15 spans[index].className = \"\";16 Bottomsoild[index].classList.remove(\"bottom\");17 &#125; 这个主要是css的实现可以关注下，有添加了平滑移动的动画 1.showup &#123;2 top: -35% !important;3 left: 0 !important;4 transition: 0.5s;5 color: black !important;6 font-weight: 600;7 font-size: 20px !important;8&#125;910.bottom &#123;11 border-bottom: 2px solid #34495e !important;12&#125; 要注意的是，input框内的登录这个两个字，会占用input的空间，所以需要做处理： input框的背景颜色需要改成透明色，再改变登录这个两个字的z-index权重，将input权重高于这两个文字，就可以覆盖这两个文字，并且可以在透明背景下正常显示。 1.accAndPass input &#123;2 height: 50px;3 width: 100%;4 outline: none;5 font-size: 25px;6 padding: 0;7 border: none;8 background-color: transparent;9 position: relative;10&#125;11.accAndPass &gt; span &#123;12 position: absolute;13 top: 50%;14 left: 3%;15 transform: translateY(-50%);16 z-index: -1;17 transition: 0.5s;18 font-size: 18px;19 color: lightgray;20&#125; 通过按钮隐藏或者显示密码 主要是更改input内的type，让其在‘text’和‘password’之间去转换,引入图片的时候，如果找不到地址，可以在地址前添加require。 1showPassWord()&#123;2 var inputs = document.getElementsByName(\"inputValue\");3 var eyes = document.getElementsByName('eyes');4 if (this.showEyes === false) &#123;5 inputs[1].type = 'text';6 eyes[1].src = this.openIcon;7 &#125;else&#123;8 inputs[1].type = 'password';9 eyes[1].src = this.closeIcon;10 &#125;11 this.showEyes = !this.showEyes;12&#125; 1closeIcon: require(\"../assets/close.png\"),2openIcon: require(\"../assets/open.png\"), 记录网站功能-电影分类电影分类通过axios获得到豆瓣top90部电影后，想要在左侧添加一个分类的侧边栏，所以需要对得到的电影进行分类。 暂时没有找到分类的api接口，只有自己通过js去循环分类出一个新的数组，新数组形式如下： 1movieGenres.push(&#123;2 index: nowGenres,3 list: [movieLists[i]]4&#125;); index:电影的类别（比如动作，冒险，剧情等等）， list：对应类别中的所有电影。 movieLists[i]：初始通过axios得到的电影详情信息（初始对象） 实现代码 实现逻辑 获取到全部电影对象 设定一个空数组用来存放分类后的全部电影：movieGenres[]。 循环全部对象，判断每一部电影的类别是否存在于新数组中， 存在则，直接添加到对应的类别数组LIst中去， 不存在，则将对应类别直接添加到新数组中， 实现代码 1formMovieG(movieLists) &#123;2 var movieGenres = [];3 for (let i = 0; i &lt; movieLists.length; i++) &#123;4 var nowGenres = movieLists[i].genres[0];5 if (toJudge(nowGenres)) &#123;6 movieGenres.push(&#123;7 index: nowGenres,8 list: [movieLists[i]]9 &#125;);10 &#125; else &#123;11 for (let j = 0; j &lt; movieGenres.length; j++) &#123;12 if (movieGenres[j].index == nowGenres)13 movieGenres[j].list.push(movieLists[i]);14 &#125;15 &#125;16 &#125;17 function toJudge(nowGenres) &#123;18 for (let i = 0; i &lt; movieGenres.length; i++) &#123;19 if (movieGenres[i].index == nowGenres) &#123;20 return false;21 &#125;22 &#125;23 return true;24 &#125;25 return movieGenres;26&#125;, movieLists:全部电影（90部没有分类） toJudge（）：判断函数，判断是否存在对应类别 ，存在则返回false，不存在则返回true； 1this.movieGenres = this.formMovieG(movieLists); 获取后赋值。 注意点 新数组的形式： 1movieGenres.push(&#123;2 index: nowGenres,3 *list: [movieLists[i]]*4&#125;); 其中list应当为一个数组的形式，因为是多个对象在其中，后续判断类别相同后，需要用push的方法推到list数组中去。 记录网站功能-动态生成li动态生成元素当获取到电影之后，一页只能显示9个电影，之后的电影则需要通过下方的分页li去显示，不同的种类的电影数量是不一致的，所以对应的下方显示数量li页不一致，所以需要根据电影数量动态生成li。 全部电影： 局部电影： 代码 逻辑 通过判断当前类目一共有多少电影去生成对应个数的下方li索引， 切换前，应当先清除所有的li，然后再生成新的li。 给每个li绑定一个点击事件，当点击时候，当前显示页面的数组替换成对应序号的数组， 代码 1// 生成下方li列表2createLiLists(Lilength) &#123;3 let that = this; //内部函数中调用函数，用that存储this指向，再调用，that.xxx4 var indexlists = document.querySelector(\"#indexLists\");5 var showindex = document.querySelector(\".showindex\");6 for (let i = 1; i &lt; Lilength; i++) &#123;7 var node = document.createElement(\"li\");8 var textIndex = document.createTextNode(i);9 node.appendChild(textIndex);10 indexlists.appendChild(node);11 node.className = \"index\";12 node.addEventListener(\"click\", function() &#123;13 that.gotoIndex(this.innerText, showindex); // that调用14 &#125;);15 &#125;16 this.liIndexList = Lilength;17 showindex.innerText = 1;18&#125;, 1// 清除li2clearLiLists() &#123;3 // this.liIndexList = Lilength;4 var indexlists = document.querySelector(\"#indexLists\");5 var liS = indexlists.querySelectorAll(\".index\");6 // 清除lis，排他7 for (var i = liS.length - 1; i &gt;= 0; i--) &#123;8 indexlists.removeChild(liS[i]);9 &#125;10&#125;, 1//点击事件2gotoIndex(e, showindex) &#123;3 var index = document.querySelectorAll(\".index\");4 // var showindex = document.querySelector(\".showindex\");5 this.isLoading = true;6 //单页面应用，定时器并不会自动关闭，需要手动清除7 var out = setInterval(() =&gt; &#123;8 if (this.allMovie.length == 90) &#123;9 if (this.liIndexList == 11) &#123;10 this.items = this.allMovie.slice(11 parseInt(e) * 9 - 9,12 parseInt(e) * 9,13 (this.isLoading = false)14 );15 &#125; else &#123;16 this.items = this.movieGenres_index_list.slice(17 parseInt(e) * 9 - 9,18 parseInt(e) * 9,19 (this.isLoading = false)20 );21 &#125;22 clearInterval(out);23 &#125;24 &#125;, 100);25 showindex.innerText = e;26 for (let i = 0; i &lt; index.length; i++) &#123;27 index[i].classList.remove(\"light\");28 &#125;29 index[e - 1].classList.add(\"light\");30&#125;, 注意点 生成元素后需要添加元素，才能生效 1var node = document.createElement(\"li\");2var textIndex = document.createTextNode(i);3node.appendChild(textIndex);4indexlists.appendChild(node); 这里生成了li和li内部的数字i，然后需要append到父元素indexlists上，才能生效。 函数内部调用函数添加事件，使用了that 1 let that = this; //内部函数中调用函数，用that存储this指向，再调用，that.xxx2 node.addEventListener(\"click\", function() &#123;3 that.gotoIndex(this.innerText, showindex); // that调用4&#125;); addEventListener内使用其他函数gotoIndex，直接使用this.gotoIndex不生效，使用that生效。 写了一个定时器，判断是否将90部电影循环完毕，再执行绑定点击跳转事件，避免未加载完成90部电影点击无效。 1var out = setInterval(() =&gt; &#123;2 if (this.allMovie.length == 90) &#123;3 if (this.liIndexList == 11) &#123;4 this.items = this.allMovie.slice(5 parseInt(e) * 9 - 9,6 parseInt(e) * 9,7 (this.isLoading = false)8 );9 &#125; else &#123;10 this.items = this.movieGenres_index_list.slice(11 parseInt(e) * 9 - 9,12 parseInt(e) * 9,13 (this.isLoading = false)14 );15 &#125;16 clearInterval(out);//单页面应用，定时器并不会自动关闭，需要手动清除17 &#125;18 &#125;, 100); 刚打开页面时候，去给li添加事件，会发现报错，因为此时，还没有获取到全部的电影，所以没有办法执行对应的数字跳转到对应的页面电影。 所以执行一个定时循环函数去判断电影是不是获取完毕，获取完毕了，再执行添加函数。 如果是有对应的api数据，则比较方便，只用获取到对应的index去后端请求。 记录网站功能-购物车网站购物车功能需要在两个页面（电影列表和电影详情）去添加一个购物车功能，而且通过购物车可以跳转到支付页面，支付页面中页可以直接修改购物车的电影数量。 一般去多页面操作同一数据，都会使用一些工具，现在用的是vue-x 。 传统方法主要是通过父子组件之间的传值来进行操作： 父组件传给子组件的数据 父组件需要在子组件标签处添加一个自定义标签 1&lt;Shop :number=\"allMovie.length\"&gt;&lt;/Shop&gt; 1import Shop from \"@/components/shoppingCar.vue\"; 1data() &#123;2 return &#123;3 allMovie: []4 &#125; 子组件需要注册props 1&lt;h4&gt;影库共有&#123;&#123;number&#125;&#125;部电影&lt;/h4&gt; 1props:[\"number\"], 这样，就可以通过标签的方法，子组件调用父组件处拿到number里的allmovie的length了。 子组件传给父组件的数据 子组件需要给元素绑定一个事件，通过事件传参 1&lt;button @click=\"toParent()\"&gt;点击传值&lt;/button&gt; 1methods: &#123;2 toParent()&#123;3 this.$emit('sendToFather',this.message)4&#125;,5&#125; 1data() &#123;2 return &#123;3 message:&#123;name:\"购物车\",color:\"red\"&#125;,4 &#125; 父组件通过调用子组件定义的一个特定名字方法来获得子组件参数 1&lt;Shop @sendToFather=\"getChild\"&gt;&lt;/Shop&gt; 1methods: &#123;2 getChild(data)&#123;3 console.log(data);4 &#125;,5&#125; 控制台会输出子组件的message数组。 购物车功能vue-x实现涉及到多个页面操作同一数据源，并且其中有页面不是父子关系。使用vue-x更加便捷 逻辑 vue-x的使用核心是两个，一个是state，另一个是mutations。 1export default new Vuex.Store(&#123;2 state: &#123;3 &#125;,4 mutations: &#123;5 &#125;,6 actions: &#123;7 &#125;,8 modules: &#123;9 &#125;10&#125;) state是页面所需要调用的一个数据源，比如我要在购物车中展示的所有电影数组，这个数组可以在购物车和支付页面都显示出来 mutations是其他页面提交新的数据过来的时候，需要对传递过来的数据做一些操作（比如要添加一些数量表示，要筛选出重复项等等），然后再赋值给state中的数据源，从而更新所有页面的数据。 代码 1export default new Vuex.Store(&#123;2 state: &#123;3 // 当前购物车的电影(经过了数量整理)4 carMovie: [],5 //数量6 totalNumber: 0,7 &#125;,8 mutations: &#123;9 setShopCar(state, arg) &#123;10 //处理数组中的重复项，将重复项剔除，并且account 加一11 for (let i = 0; i &lt; arg.length; i++) &#123;12 for (let j = 0; j &lt; arg.length; j++) &#123;13 if (i != j &amp;&amp; arg[i].object.title == arg[j].object.title) &#123;14 arg.splice(j, 1);15 j = 0;16 arg[i].account += 1;17 &#125;18 &#125;19 &#125;;20 state.carMovie = arg;21 var argTem = JSON.stringify(arg);22 window.localStorage.setItem('tempMovie',argTem);23 // 电影的数量24 var total = 0;25 for (let i = 0; i &lt; arg.length; i++) &#123;26 total += arg[i].account;27 &#125;;28 state.totalNumber = total;29 &#125;30 &#125;,31 actions: &#123;32 &#125;,33 modules: &#123;34 &#125;35&#125;) 支付页面中调用: 1computed: &#123;2 carMovie() &#123;3 return this.$store.state.carMovie;4 &#125;,5&#125; 支付页面中更新vue-x中state： 1buyTheMovie(item) &#123;2 // var reg = this.$store.state.buyCarMovieList;3 var reg = this.$store.state.carMovie;4 reg.push(&#123;5 account: 1,6 object: item7 &#125;);8 this.$store.commit(\"setShopCar\", reg);9&#125;, 注意 直接获取state数据，然后修改，这个操作是能够生效的，但是不推荐这个方法，应当所有修改state数据的操作都使用：this.$store.commit(“xxxxx”, xxx)。从而能够保证数据更新的一致性。 一般调用的时候，涉及到比较复杂的数据，都可以用再computed周期中。 记录网站功能-搜索搜索功能网站一共获取90部电影，设计了搜索功能，主要搜索依据为电影名字，因为没有找到搜索的api接口，所以直接获取到全部的90部电影后，再进行的全部的电影循环匹配，相对花的时间比较多。 实现了通过部分关键字显示对应电影，记录如下： 功能实现 逻辑实现 选择一个合适的事件 通过取得input框内的value值去对比每一部电影的title，然后可以得出判断，这里需要选择对应的input事件，参考网上的说明，选用oninput事件，找到的说明如下： 一种是onchange事件，触发条件：内容改变且失去焦点。 一种是onpropertychange事件，触发条件：元素内容改变即触发，另外js改变内容，该元素的属性改变也会触发。但只在IE11以下支持。 一种是html5的oninput事件，触发条件：value值的改变，但是js方式改变value不会触发，且在IE8以上及其他标准浏览器支持。 实际上，网上看到有新的事件对应不同的条件执行，暂时没有去尝试，直接用了防抖函数，如下： ​ 原理： ​ 当浏览器有非直接的文字输入时，compositionstart事件就会同步触发，记住，是同步 ​ 当浏览器是直接的文字输入时，compositionend事件就会触发 1var cpLock = false;2 $('input[search]').on('compositionstart', function () &#123;3 // 输入汉语拼音时锁住搜索框，不进行搜索，或者从汉语拼音转到字母时也可触发4 cpLock = true;5 console.log('不搜索')6 &#125;);7 $('input[search]').on('compositionend', function () &#123;8 // 结束汉语拼音输入并生成汉字时，解锁搜索框，进行搜索9 cpLock = false;10 console.log('汉字搜索');11 // 接下去放ajax请求生成下拉框内容12 &#125;);13 $('input[search]').on('input', function () &#123;14 if (!cpLock) &#123;15 console.log('字母搜索') 16 // 接下去放ajax请求生成下拉框内容17 &#125; 需要防抖函数 防抖函数具体见以下文章：防抖函数和节流函数 代码 代码如下： 1&lt;input id=\"searchMovie\" type=\"text\" placeholder=\"请输入......\" @input=\"doSearch\" /&gt; 1&lt;script&gt;2//防抖函数3function debounce(fn, delay = 2000) &#123;4 //可以放入项目中的公共方法中进行调用（鹅只是省事）5 let timer;6 return function() &#123;7 var args = arguments;8 if (timer) &#123;9 clearTimeout(timer);10 &#125;11 this.isLoading = true;12 this.loadingIntext = \"搜索中......\";13 if (document.getElementById(\"searchMovie\").value == \"\") &#123;14 this.items = this.firstPMovie;15 this.isLoading = false;16 this.loadingIntext = \"请稍等......\";17 &#125; else &#123;18 timer = setTimeout(() =&gt; &#123;19 fn.apply(this, args); // this 指向vue20 &#125;, delay);21 &#125;22 &#125;;23&#125;24export default &#123;25methods:&#123;26 doSearch: debounce(function() &#123;27 var searchMovieV = document.getElementById(\"searchMovie\").value;28 var res = this.allMovie;29 this.items = [];30 for (let i = 0; i &lt; res.length; i++) &#123;31 if (res[i].title.includes(searchMovieV)) &#123;32 this.items.push(res[i]);33 this.isLoading = false;34 this.loadingIntext = \"请稍等......\";35 &#125;36 &#125;37 if (this.items.length == 0) &#123;38 this.loadingIntext = \"没有找到结果哟,3秒后自动返回，稍等......\";39 this.isLoading = true;40 var setT = setTimeout(() =&gt; &#123;41 this.items = this.firstPMovie;42 this.isLoading = false;43 this.loadingIntext = \"请稍等......\";44 clearTimeout(setT);45 &#125;, 3000);46 &#125;47&#125;)48&#125;49&#125;50&lt;/script&gt; 注意 如何判断input的值是否符合电影title的关键词 1res[i].title.includes(searchMovieV) .includes函数可以判断title内有没有包含seatchmovie 的关键字，只要有对应的任意一个字，就会判断为true 再vue中使用防抖函数 debounce这个函数需要直接写再script内部，然后设置了两个参数，第一个就是执行方法，即fn，第二个是等待时间。 这里需要注意的是，debounce这个函数内部需要定义一个timer，形成一个闭包，从而使得第二次进入循环后，清除掉第一次的定时函数。 同时this的指向问题，需要再return函数中用一个变量去存以下this，以确保指针指向的是input。 参考链接：[防抖函数中的闭包]( 记录网站功能实现-精灵图精灵图 精灵图技术产生的目的：很多大型网页在首次加载的时候都需要加载很多的小图片，而考虑到在同一时间，服务器拥堵的情况下，为了解决这一问题，采用了精灵图这一技术来缓解加载时间过长从而影响用户体验的这个问题。 精灵图技术的本质：所谓精灵图就是把很多的小图片合并到一张较大的图片里，所以在首次加载页面的时候，就不用加载过多的小图片，只需要加载出来将小图片合并起来的那一张大图片也就是精灵图即可，这样在一定程度上减少了页面的加载速度，也一定程度上缓解了服务器的压力。例如王者荣耀页面里的几个小logo: 怎么去实现一张图片加载不同位置主要通过background-position属性去设置不同位置 如图： 引入背景图片 设置背景图片显示位置（实际上可以通过js的for循环去设置） 设置hover效果 优缺点优点： ①减少网页的http请求，从而加快了网页加载速度，提高用户体验。 ②减少图片的体积，因为每个图片都有一个头部信息，把多个图片放到一个图片里，就会共用同一个头信息，从而减少了字节数。 ③解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名。 ④更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。 缺点： ①在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂。 ②CSS Sprites在开发的时候，要通过photoshop或其他工具测量计算每一个背景单元的精确位置。 ③在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片。 ④精灵图不能随意改变大小和颜色。改变大小会失真模糊，降低用户体验，Css3新属性可以改变精灵图颜色，但是比较麻烦，并且新属性有兼容问题，现在一般用字体图标代替精灵图。 记录网站功能实现-搜索功能网站搜索功能很多的导航网站会再头顶设置不同的搜索引擎的搜索框，提供更方便的搜索功能，如图： 这个实现也不复杂，如下： 如何实现功能的实现也不复杂，是通过一个form，不停的变换form中的action和name去切换不同的搜索引擎的 代码如下： 1&lt;form action=\"https://www.baidu.com/s\" target=\"__blank\" id=\"searchForm\"&gt;2 &lt;input3 id=\"searchInput\"4 type=\"text\"5 placeholder=\"请输入要搜索的内容：\"6 v-model=\"searchValue\"7 name=\"word\"8 autofocus9 /&gt;10 &lt;input type=\"submit\" value=\"搜索\" /&gt;11&lt;/form&gt; 1data() &#123;2 return &#123;3 items: [4 &#123;5 text: \"谷歌\",6 searchUrl: \"http://www.google.com.hk/search?q=\",7 name: \"q\"8 &#125;,9 &#123; text: \"百度\", searchUrl: \"https://www.baidu.com/s\", name: \"word\" &#125;,10 &#123;11 text: \"搜狗\",12 searchUrl: \"http://www.sogou.com/web\",13 name: \"query\"14 &#125;,15 &#123; text: \"必应\", searchUrl: \"https://cn.bing.com/search\", name: \"q\" &#125;16 ],17 checkindex: 1,18 searchValue: \"\"19 &#125;;20&#125;, 1isActive(item, index) &#123;2 this.checkindex = index;3 document.getElementById(\"searchForm\").action = item.searchUrl;4 document.getElementById(\"searchInput\").name = item.name;5&#125;, 通过v-for去循环data中的items，去生成不同的搜索引擎按钮，点击不同的按钮，去切换form中的action和input中的name就可以实现搜索功能。 这个其中主要是通过各大搜索引擎提供的地址去操作，例如百度等，已经提供了公共的搜索接口，非常的方便。 侧边栏随动闪烁问题记录很多网站都有侧边栏随动的效果，当页面在最顶部的时候，侧边栏是正常的元素上下排列效果，当下滑到一定的位置，侧边栏会变成固定的位置。如下： 固定位置如下： 功能实现实现功能是很简单的，直接获取当前位置对应最顶部的值，然后当值大于某个数时，将元素的class增加一个fixed，当小于某个值，再移除这个class 1position: fixed !important;2transform: translateZ(0);3-webkit-transform: translateZ(0);4top: 70px; js判断如下： 1var h = this.$refs.carousel.offsetHeight;2this.scrollPosition = document.documentElement.scrollTop;3this.$store.commit(\"setScrollPosition\", this.scrollPosition);//记录当前浏览的位置，返回时可以保证用户时之前的浏览位置4console.log(this.scrollPosition);5var offtop = document.documentElement.scrollTop + 50;6if (document.body.clientWidth &gt; 972) &#123;7 if (offtop &gt; h) &#123;8 this.movieG2 = true;//增加class9 &#125; else &#123;10 this.movieG2 = false;//减少class11 &#125;12&#125; 问题这样产生了问题： 浏览器中，每次鼠标滚轮都是滚动固定的大小，每次滚动67左右。 但是当接近判断clss临界条件时，会向下滚动一次就立刻超过临界值，导致，这个侧边栏会从之前的上下排列瞬间切换到fixed排列，这中间侧边栏会闪烁一下。 我观察了其他网站的实现，发现其他网站向下滚动的距离时固定的，比如，滚动5次，刚好可以达到临界值，然后下一次滚动，刚好可以将正常的文档流改成fixed，所以没有闪烁问题。 实现功能关键属性：mousewheel事件 mousewheel事件就是鼠标滚轮滚动的事件，每次滚动，可以阻止其默认行为，然后，自己设定下滑的距离，从而实现每次滚动的距离可控。 代码如下： 1//滚轮事件2// 鼠标滚轮事件3function getWheelDelta(event) &#123;4 if (event.wheelDelta) &#123;5 return event.wheelDelta;6 &#125; else &#123;7 // 兼容火狐8 return -event.detail;9 &#125;10&#125;11// 鼠标滚动逻辑（全屏滚动关键逻辑）12function scrollMouse(event) &#123;13 event.preventDefault();14 let delta = getWheelDelta(event);15 let locationNow = document.documentElement.scrollTop;16 // delta &lt; 0，鼠标往前滚动，页面向下滚动17 if (delta &lt; 0) &#123;18 goDown(locationNow);19 &#125; else &#123;20 goUp(locationNow);21 &#125;22&#125;23function goDown(locationNow) &#123;24 window.scrollTo(0, locationNow + 80);25&#125;26function goUp(locationNow) &#123;27 if (locationNow &gt; 80) &#123;28 window.scrollTo(0, locationNow - 80);29 &#125; else &#123;30 window.scrollTo(0, 0);31 &#125;32&#125;33// 鼠标滚轮监听，火狐鼠标滚动事件不同其他34if (navigator.userAgent.toLowerCase().indexOf(\"firefox\") === -1) &#123;35 document.addEventListener(\"mousewheel\", scrollMouse, &#123; passive: false &#125;);36&#125; else &#123;37 document.addEventListener(\"DOMMouseScroll\", scrollMouse);38&#125; 实现效果每次滚动都下滑80，这样，就可以比较方便的去修正不同元素的距离。 修复前： 修复后： 通过local storage模拟了注册登录机制前后端分离模式下，网站的注册、登录机制实现，对于前端来说，主要考虑两个点： 把用户的账号校验然后发送后端申请验证码 提交用户的账号和验证码去后端校验，然后后端返回状态码（token） 以上两点可以通过localstorage去简单模拟的，记录如下： 注册登录逻辑流程需要实现的注册功能如下： 校验手机号码是否正确 正确：显示验证码（直接页面上显示一个验证码） 错误：手机号码下方提示“手机号码错误” 校验手机号码和验证码是否正确 正确：信息入库，添加如local storage，跳转至登录页面 错误：显示验证码错误或者手机号码已经注册 实现登录功能如下： 校验手机号码是否正确 正确：显示验证码（直接页面上显示一个验证码） 错误：手机号码下方提示“手机号码错误” 校验手机号码和验证码是否正确 正确：添加登录状态（token），跳转至个人中心页面 错误： 显示验证码错误或者手机没有注册 token是一个对象，里面包含了登陆后的信息。如下： 1let passUsrInfo = &#123;2 usrname: this.items1[0].value,3 token: \"pass\",4 time: Date.now(),5&#125; usrname：用户名 token：登录状态 time：登录时间 可以通过判断当前时间与time的差值去决定是否还再登录状态，我这里设置时10分钟。 实现代码1toLogin() &#123;2 if (this.common.phoneNumber(0, this.items1[0].value)) &#123;3 this.items1[0].showerr = false;4 this.items1[0].err = \"手机号码有误\";5 if (this.items1[1].value == 6666) &#123;6 this.items1[1].showerr = false;7 let tem = JSON.parse(localStorage.getItem(\"usrname\")) == null ? [] : JSON.parse(localStorage.getItem(\"usrname\"));8 let usrInfo = this.items1[0].value;9 if (tem.length == 0) &#123;10 tem.push(&#123; usrname: usrInfo &#125;);11 window.localStorage.setItem(\"usrname\", JSON.stringify(tem));12 this.registerOK = true;13 setTimeout(() =&gt; &#123;14 this.$router.push(\"/login\");15 &#125;, 3000);16 &#125; else &#123;17 let index = tem.findIndex((x) =&gt; x.usrname == usrInfo);18 if (index == -1) &#123;19 tem.push(&#123; usrname: usrInfo &#125;);20 window.localStorage.setItem(\"usrname\", JSON.stringify(tem));21 this.registerOK = true;22 setTimeout(() =&gt; &#123;23 this.$router.push(\"/login\");24 &#125;, 3000);25 &#125; else &#123;26 this.items1[0].err = \"该手机号码已经被注册\";27 this.items1[0].showerr = true;28 &#125;29 &#125;30 &#125; else &#123;31 this.items1[1].showerr = true;32 &#125;33 &#125; else &#123;34 this.items1[0].showerr = true;35 this.items1[0].err = \"手机号码有误\";36 &#125;37 &#125; 以上是登录时，判断手机号码及验证码的逻辑。说明： this.common.phoneNumber(0, this.items1[0].value) 这个是一个公共方法，用正则表达式判断手机号码是否正确 let tem = JSON.parse(localStorage.getItem(“usrname”)) == null ? [] : JSON.parse(localStorage.getItem(“usrname”)) 这个是获取到本地存储中的注册手机号码，模拟的是数据库中的注册用户信息，去判断手机号码是否注册 根据token去显示页面可以再页面加载时候去判断下localstorage内有没有对应的信息，从而去显示不同的页面： 实现代码： 首页导航栏： 1&lt;div v-if=\"showRegLogin\" class=\"col-xs-2 col-xs-offset-7 navbarRight\"&gt;2 &lt;router-link tag=\"a\" to=\"/login\"&gt;Login&lt;/router-link&gt;3 &lt;router-link tag=\"a\" to=\"/register\"&gt;Register&lt;/router-link&gt;4&lt;/div&gt;5&lt;div v-else class=\"col-xs-2 col-xs-offset-7 navbarRight\"&gt;6 &lt;router-link tag=\"a\" to=\"/center\"&gt;Center&lt;/router-link&gt;7 &lt;router-link tag=\"a\" to=\"/register\"&gt;Register&lt;/router-link&gt;8&lt;/div&gt; 1mounted() &#123;2 this.showRegLogin = !this.common.judgeLogin()3&#125; 购物车栏： 1&lt;ul v-if=\"showList\" class=\"carLists\"&gt;2 &lt;li&gt;3 &lt;div class=\"movieLists\"&gt;4 &lt;span class=\"name\"&gt;电影名称&lt;/span&gt;5 &lt;span class=\"acount\"&gt;数量&lt;/span&gt;6 &lt;/div&gt;7 &lt;/li&gt;8 &lt;li v-for=\"(item, index) in carMovie\" :key=\"index\"&gt;9 &lt;div class=\"movieLists\"&gt;10 &lt;span class=\"name\"&gt;&#123;&#123; item.title &#125;&#125;&lt;/span&gt;11 &lt;span class=\"acount\"&gt;&#123;&#123; item.account &#125;&#125;&lt;/span&gt;12 &lt;/div&gt;13 &lt;/li&gt;14&lt;/ul&gt;15&lt;ul v-else class=\"carLists\"&gt;16 &lt;li class=\"showLogin\"&gt;17 &lt;div&gt;18 还没有登录呢，点击19 &lt;router-link to=\"/login\" tag=\"span\" style=\"color:red;cursor:pointer;\"&gt;登录&lt;/router-link&gt;20 &lt;/div&gt;21 &lt;/li&gt;22&lt;/ul&gt; 1toJudge() &#123;2 this.showUp = false;3 this.isLogin = JSON.parse(window.localStorage.getItem(\"passUsrInfo\"))4 .token5 ? JSON.parse(window.localStorage.getItem(\"passUsrInfo\")).token6 : \"\";7 //false没有登录或者登录失效，true已经登录并且失效时间内8 if (this.isLogin &amp;&amp; this.common.judgeLogin()) &#123;9 this.showList = true;10 this.movieAcountLoading = true;11 &#125; else &#123;12 this.showList = false;13 &#125;14&#125; 效果如下： 未登录： 已经登录： Vue中引入图片失效引入图片自己本地开发引入图片可以选择相对路径或者绝对路径，比如： 1&lt;img :src=\"../images/1.png\"&gt; 这样是可以在网页中显示的，或者将图片放在网络存储中，引用网络地址。 但是，在使用Vue进行开发的时候，有遇到一个问题：本地引入图片生效，但是使用Js去替换图片的时候，使用相对路径，就不能正确的生成图片，查阅资料发现了需要更换引入方式。 想要实现的样式密码的显示和隐藏样式： 显示： 隐藏: 在Vue中引入图片 直接使用相对路径 直接使用相对路径生成的html里面，可以发现在引用的图片地址处，会被加上一串唯一编码。 如果用JS去修改img的src，生成的图片地址里面是没有编码的，所以不会正确的加载地址。 正确的引入 html img直接引入地址，需要在src上加上v-bind，也就是冒号： data data对应的应该有该名称的对应地址属性 methds 直接在方法里面去让src的属性等于对应的src名称 这样，可以正确的显示图片，从F12解析可以看到，图片的地址都是已经加上了编码。","categories":[],"tags":[{"name":"登录，动画","slug":"登录，动画","permalink":"http://lenmon54231.github.io.git/tags/%E7%99%BB%E5%BD%95%EF%BC%8C%E5%8A%A8%E7%94%BB/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2019-12-01T14:22:50.000Z","updated":"2019-12-03T10:04:56.780Z","comments":true,"path":"2019/12/01/markdown语法/","link":"","permalink":"http://lenmon54231.github.io.git/2019/12/01/markdown%E8%AF%AD%E6%B3%95/","excerpt":"markdown语法Markdown 是一种轻量级的「标记语言」，优点在于: 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 hexo中使用hexo中生成的文章，全部支持md语法，所以有必要学习一下语法规则，常用的规则有:","text":"markdown语法Markdown 是一种轻量级的「标记语言」，优点在于: 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 hexo中使用hexo中生成的文章，全部支持md语法，所以有必要学习一下语法规则，常用的规则有: 概述比较常用的规则如下，包括标题，内容，引用，表格等等，基本包含绝大多数文章的表达规则: 1分段: 两个回车;2换行: 两个空格 + 回车;3标题: # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题;4强调: **文字** ， __文字__ ， _文字_ ， *文字* ， 文字;5引用: &gt; 注意后面紧跟个空格;6表格: - 和 | 分割行和列 ， : 控制对其方式;7代码块: 四个空格 开头或， 使用&#96;&#96;&#96; 代码内容 &#96;&#96;&#96;;;8链接: [文字](链接地址);9图片: ![图片说明](图片地址) ，地址可以是本地路劲，也可以是网络地址;10列表: * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格; 标题 示例:1# 欢迎使用Markdown编辑器写博客 一级标题 对应 &lt;h1&gt; &lt;&#x2F;h1&gt;2## 标题输入 二级标题 对应 &lt;h2&gt; &lt;&#x2F;h2&gt;3### 三级标题 三级标题 对应 &lt;h3&gt; &lt;&#x2F;h3&gt;4#### 四级标题 四级标题 对应 &lt;h4&gt; &lt;&#x2F;h4&gt;5##### 五级标题 五级标题 对应 &lt;h5&gt; &lt;&#x2F;h5&gt;6###### 六级标题 六级标题 对应 &lt;h6&gt; &lt;&#x2F;h6&gt; 内容 示例:1字体: **加粗** 2字体: *斜体* 3字体: ***加粗并斜体*** 4删除线: ~~删除一段文本~~ 效果: 加粗斜体加粗并斜体删除一段文本 引用 示例:1&gt;这是引用的内容2&gt;&gt;这是引用的内容3&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果: 这是引用的内容 这是引用的内容 这是引用的内容 分割线 示例:1---2----3***4***** 效果: 图片 示例:1![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;) 超链接 示例: 1[超链接名](超链接地址 &quot;超链接title&quot;)2title可加可不加3[简书](http:&#x2F;&#x2F;jianshu.com)4[百度](http:&#x2F;&#x2F;baidu.com) 效果: 简书百度 列表 示例: 无序列表: 1- 列表内容2+ 列表内容3* 列表内容 有序列表: 11.列表内容22.列表内容33.列表内容 效果: 无序列表: 列表内容 列表内容 列表内容 有序列表: 1.列表内容2.列表内容3.列表内容 表格 示例:1姓名|技能|排行2--|:--:|--:3刘备|哭|大哥4关羽|打|二哥5张飞|骂|三弟 效果: 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码 示例:1`printf()` 函数;2​```javascript3$(document).ready(function () &#123;4 alert('RUNOOB');5&#125;);6​ 1* 效果:2&gt;&#96;&#96;&#96;javascript3&gt;$(document).ready(function () &#123;4&gt; alert(&#39;RUNOOB&#39;);5&gt;&#125;)6&gt; 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 1\\ 反斜线2&#96; 反引号3* 星号4_ 下划线5&#123;&#125; 花括号6[] 方括号7() 小括号8# 井字号9+ 加号10- 减号11. 英文句点12! 感叹号 ASCII 代码HTML 和 XHTML 用标准的 7 比特 ASCII 代码在网络上传输数据。7 比特 ASCII 代码可提供 128 个不同的字符值。点击此处跳转至ASCII","categories":[],"tags":[]}]}