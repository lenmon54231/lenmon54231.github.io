---

title: 可能用到的请求
date: 2020-07-12 17:16:26
tags: [js,hexo]
---

<meta name="referrer" content="no-referrer"/>

## 可能用到的请求和下载

### vue中的axios请求

```js
import axios from 'axios'
const host = require('./host')
import { Message } from 'element-ui'

const service = axios.create({
  baseURL: host.host,
  timeout: 60000000,
})

service.interceptors.request.use(
  (config) => {
    const token = sessionStorage.getItem('token')

    config.headers = token
      ? { Authorization: 'Bearer ' + sessionStorage.getItem('token') }
      : ''

    if (config.ContentType) {
      config.headers['Content-Type'] = config.ContentType
      delete config.ContentType
    }
    if (
      //本地环境情况下，需要把login的host写死。避免频繁的切换host
      process.env.VUE_APP_DEBUG === 'development' &&
      config.url.split('?')[0] == '/admin/login'
    ) {
      config.baseURL = process.env.VUE_APP_HOST
    } else {
      //测试环境或者正式环境，需要将所有的host改成环境文件中的host
      switch (config.basicUrl) {
        case '/mall':
          config.baseURL = process.env.VUE_APP_HOST1
          break
        default:
          config.baseURL = process.env.VUE_APP_HOST
          break
      }
    }
    return config
  },
  (error) => {
    return Promise.reject()
  }
)

service.interceptors.response.use(
  (response) => {
    if (response.status === 200) {
      if (response.data.code === 200) {
        return response.data
      } else {
        Message({
          message: response.data.msg,
          type: 'error',
          duration: 2 * 1000,
        })
        return Promise.reject()
      }
    } else {
      return Promise.reject()
    }
  },
  (error) => {
    if (String(error).includes('Network Error')) {
      Message({
        message: '网络出错了,请检查网络',
        type: 'error',
        duration: 2 * 1000,
      })
      return Promise.reject(error)
    } else if (error.response.status === 500 || error.response.status === 403) {
      Message({
        message: '登录已失效，请重新登录',
        type: 'error',
        duration: 2 * 1000,
      })
      setTimeout(function() {
        sessionStorage.removeItem('resources')
        sessionStorage.removeItem('token')
        sessionStorage.removeItem('adminUserInfo')
        window.location.href =
          process.env.NODE_ENV === 'development'
            ? window.location.protocol +
              '//' +
              window.location.host +
              '/#/login'
            : window.location.protocol +
              '//' +
              window.location.host +
              process.env.VUE_APP_PUBLIC +
              '#/login'
      }, 2000)
    } else if (
      error.response.data.message === 'The service or item was not found.'
    ) {
      Message({
        message: '平台升级中...',
        type: 'error',
        duration: 2 * 1000,
      })
      return Promise.reject(error)
    } else {
      Message({
        message: error.response.data.message,
        type: 'error',
        duration: 2 * 1000,
      })
      return Promise.reject(error)
    }
  }
)

export default service

```

### uni中的请求

```js
import { browser, Phone } from '@/utils/net.js'
const request = async (config) => {
  // ****************APP打包请求url配置****************
  //   @当APP进行打包后，从process.env.NODE_ENV获取得到的总是'production'，需要新加一种手动控制url的字段，by:李蒙

  // let currentEnv = 'development' //打包APP时使用测试地址
  let currentEnv = 'production' //打包APP时使用正式地址
  if (!uni.getStorageSync('currentEnv'))
    uni.setStorageSync('currentEnv', currentEnv)
  // ****************APP打包请求url配置****************

  let baseUrlDev = 'http://wx.114family.cn/family-iface-dev' //默认请求
  let bseUrlPro = 'https://wechat.114family.cn/family-iface' //默认请求
  let WXbaseUrlDev = 'http://wx.114family.cn/family-iface-tiny-dev' //微店请求
  let WXbaseUrlPro = 'https://wechat.114family.cn/family-iface-tiny' //微店请求
  let isDev = currentEnv == 'production' //true为正式环境，false为测试环境

  // 1.对基础url进行逻辑判断
  if (config.isV) {
    //是否是微店请求
    config.url = isDev ? WXbaseUrlPro + config.url : WXbaseUrlDev + config.url
    if (!uni.getStorageSync('__urlisV__')) {
      uni.setStorageSync('__urlisV__', isDev ? WXbaseUrlPro : WXbaseUrlDev)
    }
  } else if (config.isPay) {
    //是否是支付请求
    config.url =
      'https://share.qingmh.com/wechat-pay-common/wechatpay/hjt/create'
  } else if (config.isPayQuery) {
    // 是否是支付结果查询接口
    config.url =
      'https://share.qingmh.com/wechat-pay-common/wechatpay/order/query'
  } else {
    //默认请求
    config.url = isDev ? bseUrlPro + config.url : baseUrlDev + config.url
    if (!uni.getStorageSync('url')) {
      uni.setStorageSync('url', isDev ? bseUrlPro : baseUrlDev)
    }
  }
  config.header = {
    region: '',
    terminalcode: '', // 设备号,PC端传浏览器版本号
    terminaltype: '', // 端口类型，例如 APP,XCX,WECHAT,WEB
    stoken: '', // 授权
    devicetype: '', //所属平台,例如 IOS,ANDROID,XCX,WECHAT,WEB(浏览器名称)
  }

  //region :lat	是	string纬度,lng	是	string经度,province	是	string省,city	是	string市,district	否	string区县,
  //street	否	string街道,street_number	否	string街道号
  let platform = uni.getStorageSync('platform') // 机型
  let stoken = uni.getStorageSync('stoken') // 获取后台反的token
  let isfirstGetSysInfo = uni.getStorageSync('firstGetSysInfo') //判断是否已经获取了设备的信息(某些浏览器，无法在第一次打开时获取信息，所以额外的添加了字段)
  // 2.对提供的options进行逻辑判断
  if (config.needToken) {
    //当前请求是否需要token
    if (stoken == '' || stoken == null || stoken == undefined || !stoken) {
      //当请求中没有token时，直接跳到登录页，by：李蒙
      uni.reLaunch({
        url: '/pages/Login/otherLogin',
      })
    } else {
      const region = {
        lat: '30.680905',
        lng: '104.117462',
        province: '四川省',
        city: '成都市',
      }
      // if (uni.getStorageSync('region')) {
      //   let regData = JSON.parse(uni.getStorageSync('region'))
      //   region = { ...region, ...regData }
      // }

      // config.header.region = encodeURIComponent(JSON.stringify(region))
      config.header.stoken = stoken
    }
  }
  //新增请求头内的devicetype等信息
  if (isfirstGetSysInfo == 'done') {
    //获取了手机系统信息
    config.header.terminalcode = uni.getStorageSync('model')
    config.header.terminaltype = 'WAP'
    config.header.devicetype = uni.getStorageSync('platform')
  } else {
    //未获取手机系统信息
    let getSystemInfoSync = await uni.getSystemInfoSync()
    uni.setStorageSync('firstGetSysInfo', 'done')
    let devicetypeTem = 'android'
    let modelTem = 'WAP'
    console.log(getSystemInfoSync, '2222222')
    if (getSystemInfoSync && getSystemInfoSync.platform == 'other') {
      //当使用wap开发时，有可能获取不到系统信息，改用navigator.userAgent
      let ua = browser()
      let phone = Phone()
      console.log(ua, phone, '获取的浏览器数据')
      config.header.terminalcode = ua.split('/') && ua.split('/')[0]
      config.header.terminaltype = 'WAP'
      config.header.devicetype = phone
    } else {
      devicetypeTem =
        getSystemInfoSync.platform == 'devtools'
          ? 'ios'
          : getSystemInfoSync.platform
      modelTem = getSystemInfoSync.model ? getSystemInfoSync.model : 'android'
    }
    console.log(modelTem, '1111')
    config.header.terminalcode = modelTem
    config.header.terminaltype = 'WAP'
    config.header.devicetype = devicetypeTem
    //本地存储，后续可能会用到
    uni.setStorageSync('model', modelTem)
    uni.setStorageSync('platform', devicetypeTem)
    uni.setStorageSync('windowWidth', getSystemInfoSync.windowWidth)
    uni.setStorageSync('windowHeight', getSystemInfoSync.windowHeight)
    uni.setStorageSync('safeAreaH', getSystemInfoSync.safeArea.height)
    uni.setStorageSync('safeAreaT', getSystemInfoSync.safeArea.top)
    uni.setStorageSync('statusBarHeight', getSystemInfoSync.statusBarHeight)
  }
  if (!config.data) {
    config.data = {}
  }
  //存储一下configHeaderInfo,当你跳转到图文海报的h5的时候，需要将header做一个替换
  if (!uni.getStorageSync('configHeaderInfo'))
    uni.setStorageSync('configHeaderInfo', config.header)
  //   console.log(config, '*****请求中携带的参数********')
  // 3.将已经配置好的uni.request作为一个promise返回
  let promise = new Promise((resolve, reject) => {
    uni
      .request(config)
      .then((responses) => {
        console.log(responses, '返回的数据')
        if (responses[0]) {
          //   if (uni.getStorageSync('firstLogin')) {
          //     reject({ message: '网络超时' })
          //   } else {
          uni.clearStorageSync()
          uni.reLaunch({
            url: '/pages/Login/otherLogin',
          })
          //   }
        } else {
          let response = responses[1].data // 如果返回的结果是data.data的，嫌麻烦可以用这个，return res,这样只返回一个data
          if (
            (response.code === '0016' && response.message === '口令认证失败') ||
            response.code === '00909' ||
            response.message === '网络超时'
          ) {
            uni.clearStorageSync()
            uni.reLaunch({
              url: '/pages/Login/otherLogin',
              fail(e) {
                console.log(e)
              },
            })
            console.log('触发认证失败', response)
          } else {
            resolve(response)
          }
        }
      })
      .catch((error) => {
        reject(error)
      })
  })
  return promise
}

export default request

```

## 下载oss地址文件

```js
downLoadFile(e) {
      console.log(e, 'e')
      let str = e.name.split('.')[0]
      //   this.downloadByAxios(e.url, str)
      let urlstr = e.url.replace('http', 'https')
      console.log(urlstr, 'urlstr')
      this.download(urlstr, str)
    },
```

```js
    download(url, filename) {
      /**
       * 下载
       * @param  {String} url 目标文件地址
       * @param  {String} filename 想要保存的文件名称
       */
      this.getBlob(url, (blob) => {
        this.saveAs(blob, filename)
      })
    },
    getBlob(url, cb) {
      /**
       * 获取 blob
       * @param  {String} url 目标文件地址
       * @return {cb}
       */
      var xhr = new XMLHttpRequest()
      xhr.open('GET', url, true)
      xhr.responseType = 'blob'
      xhr.onload = function() {
        if (xhr.status === 200) {
          cb(xhr.response)
        }
      }
      xhr.send()
    },
    saveAs(blob, filename) {
      /**
       * 保存
       * @param  {Blob} blob
       * @param  {String} filename 想要保存的文件名称
       */
      if (window.navigator.msSaveOrOpenBlob) {
        navigator.msSaveBlob(blob, filename)
      } else {
        var link = document.createElement('a')
        var body = document.querySelector('body')
        link.href = window.URL.createObjectURL(blob)
        link.download = filename
        // fix Firefox
        link.style.display = 'none'
        body.appendChild(link)
        link.click()
        body.removeChild(link)
        window.URL.revokeObjectURL(link.href)
      }
    },
```

## 下载服务器文件

```js
export function exportInfo(info) {
  return new Promise((resolve, reject)=>{
    axios({
      method:info.method,
      url:info.params ? info.url+ setUrlParam(info.params) : info.url,
      data:info.params,
      responseType: info.responseType, // 优先尝试 blob
      headers:{'Authorization':localStorage.getItem('token') ?'Bearer '+localStorage.getItem('token'):''}
    }).then((res) => {
      let objectUrl = null,blob = null;
      if(info.type === 'excel'){
        blob = new Blob([res.data], {
          type: "application/vnd.ms-excel"
        });
        objectUrl = URL.createObjectURL(blob);
      }else if(info.type === 'img'){
        objectUrl = 'data:image/png;base64,' + btoa(new Uint8Array(res.data).reduce((data, byte) => data + String.fromCharCode(byte), ''));
      }else if(info.type === 'zip'){
        blob = new Blob([res.data], {type: 'application/zip'});
        objectUrl = URL.createObjectURL(blob);
      }else if(info.type === 'doc'){
        blob = new Blob([res.data], {
          type: "application/msword"
        });
        objectUrl = URL.createObjectURL(blob);
      }
      let a = document.createElement("a");
      a.href = objectUrl;
      a.download = info.name;
      //a.click();
      //下面这个写法兼容火狐
      a.dispatchEvent(new MouseEvent('click', {bubbles: true, cancelable: true, view: window}));
      window.URL.revokeObjectURL(blob);
      resolve(res)
    }).catch(error => {
      console.log("response: ", error);
      reject(error)
    })

  })
}
```

## 前端下载并打包zip

```js
require('script-loader!file-saver');
import JSZip from 'jszip'
import FileSaver from 'file-saver'
const getFile = (url) => {
  return new Promise((resolve,reject)=>{
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "arraybuffer";
    xhr.onerror = function() {/* handle errors*/};
    xhr.onload = function() {
      if (xhr.status === 200) {
        resolve(xhr.response)}
      else {
        reject({})
      }
    }
    xhr.send();
  })
};

export async function exportZip( data,  zipName) {
  const zip = new JSZip()
  const cache = {}
  const promises = []
  await data.forEach(item => {
      const promise = getFile(item.url).then(data => { // 下载文件, 并存成ArrayBuffer对象
      zip.file(item.name+'.jpg', data, {
        binary: true
      }) // 逐个添加文件
      cache[item.name] = data
    })
    promises.push(promise)
  })
  Promise.all(promises).then(() => {
    zip.generateAsync({
      type: "blob"
    }).then(content => { // 生成二进制流
      console.log(content)
      saveAs(content, zipName+".zip") // 利用file-saver保存文件
    })
  })
 }
```

